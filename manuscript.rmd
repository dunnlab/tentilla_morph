---
bibliography: manuscript.bib
csl: systematic-biology.csl
site: "bookdown::bookdown_site"
output:
  bookdown::pdf_document2:
    toc: FALSE
---

```{r setup, include=FALSE}
	# Load packages
	## General
library(knitr)
library(tidyverse)
library(stringr)
library(reshape2)
	## Biological
library(Rphylip)
library(arbutus)
library(vegan)
library(ape)
library(phangorn)
library(phytools)
library(OUwie)
library(picante)
library(geiger)
library(phylobase)
library(fields)
library(phylosignal)
library(geomorph)
library(phylopath)
library(phylolm)
	## Graphics
library(FactoMineR)
library(factoextra)
library(corrplot)
library(BAMMtools)
library(gridExtra)
library(xtable)
library(colorRamps)

	# Configure knitr, see http://yihui.name/knitr/options
	opts_knit$set(
	  progress=TRUE,
	  verbose=TRUE)
	opts_chunk$set(
	#  include=FALSE,
	  cache=TRUE,
	  echo=FALSE,
	  message=FALSE
	 )
	# Set paths to input data
	setwd("~/tentilla_morph")
	
	#Load raw data
  read.csv("byslide.csv") -> numbers
  numbers$Species = as.character(numbers$Species)
  categorical <- read.csv("Homolog_Categorical.csv")[,-2]
  rownames(categorical) = categorical$Species
  
  #Correct species spellings
  numbers$Species[which(numbers$Species == "Agalma okeni")] <- "Agalma okenii"
  numbers$Species[which(numbers$Species == "Forskalia edwardsi")] <- "Forskalia edwardsii"
  numbers$Species[which(numbers$Species == "Rhizophysa eysenhardti")] <- "Rhizophysa eysenhardtii"

  #Merge Nanomias
  numbers$Species[which(numbers$Species == "Nanomia cara")] <- "Nanomia sp"
  numbers$Species[which(numbers$Species == "Nanomia bijuga")] <- "Nanomia sp"
  
  #Polish fields
  castnumbers = numbers
  castnumbers[castnumbers=="needDIC"] <- NA
  castnumbers[castnumbers=="needConfocal"] <- NA
  castnumbers[castnumbers=="needMature"] <- NA
  castnumbers[castnumbers=="needReslide"] <- NA
  castnumbers[castnumbers==-1] <- NA
  castnumbers[,c(-1,-2,-3)] <- sapply(castnumbers[,c(-1,-2,-3)],as.character)
  castnumbers[,c(-1,-2,-3)] <- sapply(castnumbers[,c(-1,-2,-3)],as.numeric)
  
  #Define functions to deal with NAs and decimals
  mean.na <- function(a){mean(a, na.rm = TRUE)}
  var.na <- function(a){var(a, na.rm = TRUE)}
  round3 <- function(a){round(a, 3)}
  
  #Compute morphometric ratios
  coiledness = castnumbers$Cnidoband.free.length..um./castnumbers$Cnidoband.length..um.
  heteroneme_elongation = castnumbers$Heteroneme.free.length..um./castnumbers$Heteroneme.width..um.
  haploneme_elongation = castnumbers$Haploneme.free.length..um./castnumbers$Haploneme.width..um.
  desmoneme_elongation = castnumbers$Desmoneme.length..um./castnumbers$Desmoneme.width..um.
  rhopaloneme_elongation = castnumbers$Rhopaloneme.length..um./castnumbers$Rhopaloneme.width..um.
  heteroneme_shaft_extension = castnumbers$Heteroneme.free.length..um./castnumbers$Heteroneme.shaft.free.length..um.
  Heteroneme_to_CB = castnumbers$Heteroneme.free.length..um./(castnumbers$Cnidoband.free.length..um.+0.001)
  total_heteroneme_volume = castnumbers$Heteroneme.volume..um3.*castnumbers$Heteroneme.number
  total_haploneme_volume = (castnumbers$Cnidoband.free.length..um./castnumbers$Haploneme.width..um.)*((4*pi/3)*0.5*castnumbers$Haploneme.free.length..um.*((0.5*castnumbers$Haploneme.width..um.)^2))
  cnidomic_index = log(total_heteroneme_volume + total_haploneme_volume)
  cnidomic_index[which(is.na(cnidomic_index))] <- log(total_haploneme_volume[which(is.na(cnidomic_index))])
  cnidomic_index[which(is.na(cnidomic_index))] <- log(castnumbers[which(is.na(cnidomic_index)), "Heteroneme.volume..um3."])
  cnidomic_index[cnidomic_index==-Inf]<-NA
    morphometrics = data.frame(castnumbers$slide_id, castnumbers$Species,coiledness, heteroneme_elongation, haploneme_elongation, desmoneme_elongation, rhopaloneme_elongation,heteroneme_shaft_extension, Heteroneme_to_CB, total_heteroneme_volume, total_haploneme_volume, cnidomic_index)
  names(morphometrics)[1:2] = c("slide_id"," Species")
  castnumbers = data.frame(castnumbers,morphometrics[,c(-1,-2)])
  
  #logtransform variables which are not normal
  castlogs = castnumbers
  non_normal = apply(castnumbers[,c(-1,-2,-3)], 2, shapiro.test) %>% lapply(function(x){x$p.value}) %>% unlist() 
  non_normal = which(as.vector(non_normal) < 0.05)+3
  castlogs[,non_normal] <- sapply(castnumbers[,non_normal], log)
  castlogs[castlogs==-Inf]<-NA
  
  #Means, varinces, standard errors
  castmeans <- aggregate(. ~  Species, data = castnumbers[,c(-1,-3)], mean.na, na.action = na.pass)
  castmean_logs <- aggregate(. ~  Species, data = castlogs[,c(-1,-3)], mean.na, na.action = na.pass)
  castvariances <- aggregate(. ~  Species, data = castnumbers[,c(-1,-3)], FUN = var.na, na.action = na.pass) #[,-2]
  castvariance_logs <- aggregate(. ~  Species, data = castlogs[,c(-1,-3)], FUN = var.na, na.action = na.pass)
  castvariances[is.na(castvariances)] <- 0
  castvariance_logs[is.na(castvariance_logs)] <- 0
  castN <- aggregate(. ~  Species, data = castnumbers[,c(-1,-3)], length, na.action = na.pass) 
  castN = data.frame(castN$Species, rowMeans(castN[,-1])) #[,-2]
  names(castN) = c("Species", "N_specimens")
  castSE <- cbind(castvariances$Species, sqrt(castvariances[,-1])/sqrt(castN$N_specimens))
  castSE_logs <- cbind(castvariance_logs$Species, sqrt(castvariance_logs[,-1])/sqrt(castN[,-1]))
  names(castSE)[1] <- "Species"
  names(castSE_logs)[1] <- "Species"
  
  
#Define fx Phenogram
Phenogram <- function(a,b,c){
  contTrait <- a
  names(contTrait) = rownames(b)
  contTrait = contTrait[!is.na(contTrait)]
  treeI = drop.tip(c,which(!(c$tip.label %in% names(contTrait))))
  A<-fastAnc(treeI,contTrait,CI=TRUE)
  paintree<-paintSubTree(treeI,node=length(c$tip)+1,"1")
  trans<-as.character(floor(0:50/2))
  trans[as.numeric(trans)<10]<- paste("0", trans[as.numeric(trans)<10],sep="")
  for(i in 0:50){
    p<-i/length(trans)
    phenogram(treeI,c(contTrait,(1-p)*A$CI95[,1]+p*A$ace), colors=setNames(paste("#0000ff",trans[i+1],sep=""),1), add=i>0)
    phenogram(treeI,c(contTrait,(1-p)*A$CI95[,2]+p*A$ace), colors=setNames(paste("#0000ff",trans[i+1],sep=""),1), add=TRUE)
  }
  phenogram(treeI,c(contTrait,A$ace),add=TRUE, colors=setNames("black",1))
}
```

# The evolution of siphonophore tentilla reveals association with diet {-}

Alejandro Damian-Serrano^1^,^‡, Steven H.D. Haddock^2^, Casey W. Dunn^1^

^1^ Department of Ecology and Evolutionary Biology, Yale University, New Haven, CT 06520, USA

^2^ Monterey Bay Aquarium Research Institute, Moss Landing, CA 95039, USA

\‡ Corresponding author, alejandro.damianserrano@yale.edu

## Abstract {-}

Siphonophores have the most complex nematocyst batteries of all Cnidaria. These structures are held on the tentacles’ side branches called tentilla. Tentilla serve as the principal organs for prey capture, making siphonophores an ideal system for the study of trophic specialization from an evolutionary approach. Modern comparative methods have been applied to study the evolution of siphonophore zooid types, but not yet to the unique morphological diversity of siphonophore tentilla. The primary objectives of this work are to describe the morphology and morphometrics of siphonophore tentilla and nematocysts, and identify patterns in the evolutionary history of siphonophore cnidoband and nematocyst morphologies. A phylogeny with 55 species was reconstructed using 18S and 16S gene markers, constraining the topology to be congruent with a transcriptome-based tree. Morphological characters were measured from DIC and confocal microscopy images of fixed tentacle specimens. Diet data was extracted from published sources. The functional implications of the different morphologies during prey capture were recorded using high speed video on live specimens under a stereoscopic microscope. Evolutionary transitions in siphonophore tentilla present a very low dimensionality with a single principal component. This main axis of variation aligns with total nematocyst volume per tentillum. Most nematocyst complement (cnidome) traits appear to have evolved under simple Brownian Motion (BM) and Early Burst (EB) processes, while tentillum shape and size evolution is better represented by Ohrnstein-Uhlenbeck (OU) models. Many tentillum and cnidome traits show stronger supports towards OU models when diet is reconstructed on the tree as selective regimes. Using phylogenetic GLS we identified traits with correlated evolutionary histories, some of which are functionally coupled during prey capture. Size and abundance of nematocysts were phylogenetic correlated with prey type ratios in the diet. These patterns could represent macroevolutionary adaptive responses to prey availability leading to predatory specialization. Understanding the evolution of the prey capture apparatus of siphonophores can help us test hypotheses about the evolution of their predatory habits.

## 1. Introduction {-}

Siphonophores are colonial planktonic predators present in all oceans of the world. 

Siphonophores bear the most complex nematocyst batteries of all cnidarians, with up to 4 types of positionally and morphologically differentiated nematocysts, combined with a spring-release mechanism for fast discharge of the structure onto the prey. Not all siphonophores bear tentilla on their tentacles, exceptions include *Apolemia* spp. and *Bathyphysa conifera*. While *Physalia physalis* has been considered to have simple tentacles, it is likely that their button-like structures are homologous to reduced tentilla [@munro2018improved]. All tentilla are unilateral side branches of the tentacle, with epidermis, mesoglea, gastrodermis, and gastrovascular cavity.
Each gastrozooid bears a single tentacle. Each tentacle serially buds tentilla from the basal region (basigaster), which develop as they are displaced further with tentacle growth. During development, tentilla grow and change shape into their final configuration while mature nematocysts formed in the basigaster migrate through the tentacle epidermis into the tentillum. Nematocysts arriving into the developing tentillum then rearrange into their final position [@skaer1991remodelling]. Tentilla are a single-use ensnaring weapon which is ingested and digested together with the prey it attached to.
The cnidoband and terminal filament bear all the active nematocysts. Cnidobands range in size from 40 microns to 8 cm, they can be coiled or straight, free hanging or enclosed in an involucrum [@mapstone2014global]. Cnidobands always carry haploneme nematocysts, which can be isorhizas or anisorhizas. In additon, many species' cnidoband can carry a row of heteroneme nematocysts along each side. These heteroneme nematocyst can be stenoteles, microbasic mastigophores, euryteles, or birhopaloids.
In codonophorans, tentilla bear a pair of elastic strands [@totton1965synopsis] derived from the wall of the gastrovascular cavity.

While zooid type evolution has been addressed in a phylogenetic framework, tentillum and nematocyst morphology has not. Since tentilla are used exclusively for prey capture, we expect their morphological diversity to have evolved in adaptive response to the evolution of different diets and prey type specializations. Earlier work by Purcell [@purcell1984functions] has shown clear associations between nematocyst morphology, size, and number with prey type and copepod prey length. However, this pioneer study did not take phylogenetic relationships into account beyond grouping species by taxonomic suborder, and eas limited to a few epipelagic species. 

## 2. Methods {-}

### 3.1 Phylogeny{-}

For this phylogenetic analysis we included 55 siphonophore species and 6 outgroup cnidarian species (*Clytia hemisphaerica*, *Hydra circumcincta*, *Ectopleura dumortieri*, *Porpita porpita*, *Velella velella*, *Staurocladia wellingtoni*).
The gene sequences used in this study are available online (accession numbers in Supp. Table XX). Some of these sequences were used in [@dunn2005molecular], others were sequenced by XYZ. Sequences were aligned using MAFFT.

A Maximum Likelihood (ML) phylogeny (Figure XX) was reconstructed from 16S and 18S ribosomal rRNA genes using IQTree (Nguyen et al., 2015) with 1000 bootstraps. We used ModelFinder (Kalyaanamoorthy et al., 2017) implemented in IQTree v1.5.5. to assess relative model fit. ModelFinder selected GTR+R4 for having the lowest Bayesian Information Criterion score. A minimal set of 5 nodes were constrained to be consistent with the [@munro2018improved] transcriptome phylogeny strict consensus tree. In addition to the ML tree, we reconstructed a Bayesian tree with each marker as an independent partition in RevBayes. The same node constraints were applied, and the tree topology recovered was identical to the ML tree.
To obtain ultrametric branch lengths for this topology, a Bayesian strict molecular clock time-tree was constructed in Rev Bayes, using a birth-death process constrained to be fully congruent with the topology recovered in the abovementioned analyses. Scripts availabe in Suppl. Mat. XX.

### 3.2 Microscopy{-}

Specimens from the Monterey Bay and Gulf of California were collected by remotely operated underwater vehicles (ROV) or by blue-water SCUBA divers, following the protocols established in [@haddock2005scientific].

All specimens are accessioned in the Yale Peabody Museum Invertebrate Zoology Collection. Accession numbers and collection data for the specimens are available in Supplementary Table XXX. All specimens were preserved in ~4% buffered formalin in seawater.

A total of 39 siphonophore species were selected based on availability and phylogenetic representativity criteria to capture intraspecific variation. Three to five specimens from each selected species were measured in order to account for intraspecific variation. Adittionally, 30 species with only a single specimen were also measured and reported in this work, but their data will not be used in the statistical analyses downstream.

Tentacles from the studied specimens were dissected, dehydrated in a series of ethanol dilutions (25% in PBS, 50% in PBS, 75% in water, 100%), cleared in methyl salicylate or d-limonene, and mounted in plastic slides (Canada balsam, Cytoseal, or Permount). Slides were imaged using laser scanning confocal microscopy and differential interference contrast (DIC) microscopy. Images were measured using Fiji-ImageJ [@schindelin2012fiji].

The characters measured for this study are described in Supplementary Table SXX. Homology assumptions for nematocyst supertypes (heteroneme, haploneme, rhopaloneme, and desmoneme) and tentillum structures (involucrum, elastic strand, pedicle, cnidoband) were informed by positional, developmental, and morphological criteria.

Diet data for epipelagic siphonophroes was compiled from published studies on visual gut content recognition [@purcell1981dietary], [@purcell1984functions]. Presence of taxonomic groups in the diet as well as percent individual composition was retrieved from these sources. For deep dwelling species, MBARI VARS [@schlining2006mbari] observations were used to score presence of prey taxonomic groups in annotated predation events with different siphonophore species.

### 3.3 Phylogenetic Comparative Methods{-}

All phylogenetic statistical analyses were carried out in the programming environment R [@team2017r], using the species tree, and incorporating intraspecific variation estimated from the specimen data. Phylogenetic signal in each of the measured characters was calculated using Blomberg’s K [@blomberg2003testing]. The phylogenetic signal of multivariate character sets was calculated using the package geomorph [@adams2016geomorph].

Ancestral states were reconstructed using ML for continuous characters (anc.ML [@revell2012phytools]), and stochastic character mapping (make.simmap) for categorical characters.

Different models generating the observed data distribution given the phylogeny were fitted for each continuous character using the function fitContinuous [@harmon2007geiger]. The models compared were the white noise (WN) (non-phylogenetic), the Brownian Motion (BM) model of neutral divergent evolution [@martins1996phylogenies], the Early Burst (EB) model of decreasing rate of evolutionary change [@harmon2010early], and the Ohnstein-Uhlenbeck (OU) model of stabilizing selection around a fitted optimum state [@uhlenbeck1930theory],[@butler2004phylogenetic]. Models were ranked in order of increasing parametric complexity (WN,BM,EB,OU). Corrected Akaika Information Criterion support scores [@sugiura1978further] were compared to the lowest (best) score, and a cutoff of 2 units was used to determine significantly better support. If the best fitting model is not significantly better than a less complex alternative, the least complex model is selected. The models selected for each character were evaluated in terms of model adequacy using the package arbutus [@pennell2015model]. Multivariate BM and OU models were also evaluated using the package mvSLOUCH [@bartoszek2012phylogenetic].

In order to explore the correlational structure among continuous characters and among their evolutionary histories, we used principal component analyses (PCA) and phylogenetic PCA [@revell2012phytools]. In addition, we obtained the correlations between the phylogenetic independent contratsts [@felsenstein1985phylogenies] using the package rphylip [@revell2014rphylip]. We modeled the relationship between correlated characters using phylogenetic leats squares regression (PGLS) in the package phytools (Revell..cite). Evolutionary relationships between continuous and categorical characters were assessed using phylogenetic ANOVAs (phyl.anova phytools) and phylogenetic generalized linear mixed models (PGLMM).

### 3.4 High-Speed Video

High speed footage (1000-3000 fps) of tentillum and nematocyst discharge was recorded on live siphonophore specimens using a Phantom Miro 320S camera mounted on a stereoscopic microscope. Specimens were collected by SCUBA divers and the remotely operated underwater vehicle Doc Ricketts during expeditions onboard the R/V Western Flyer. Tentillum and nematocyst discharge were elicited mechanically using a fine metallic pin. Video footage was analyzed using Phantom PCC software. 

Total cnidoband discharge time (ms), average cnidoband discharge speed (mm/s), maximum cnidoband discharge speed (mm/s), heteroneme discharge speed (mm/s), haploneme discharge speed (mm/s), heteroneme shaft discharge speed (mm/s), and heteroneme filament length (microns) were measured when possible for 10 species.

## 3. Results {-}

0 -- PHYLOGENY
0.0 ML ribosomal marker phylogeny constrained by transcriptome tree with BS values at the nodes.

The topology of this tree is congruent with the results from [@dunn2005molecular]. In addition, we found *Erenna* and *Stephanomia* as sister genera in a monophyletic group.

1 -- DESCRIPTIVE MORPHOLOGY AND EVOLUTIONARY HISTORY

1.05 Plate with all the tentillum diversity.

1.1 Table showing each character’s (illustrating the character per row)  the phylogenetic signal K with the p-value obtained by testing against 1000 simulated permutations, and the number of specimens included.

Principal component analyses were carried out separately on raw log-transformed measurements and compound morphometric characters (such as volumes and ratios).
PC1 (aligned with tentillum size and nematocyst shape) explains ~64% of the variation in the tentillum morphospace, whereas PC2 (aligned with nematocyst size characters) explained ~18%.

Controlling for phylogenetic expected covariance, ~88% of the evolutionary variation is explained by shifts in size, exhibiting a low effective dimensionality. 

The calycophoran morphospace is quite distinct from that of other siphonophores. A non-calycophoran (*Frillagalma vityazi*), has secondarily “invaded” this morphospace, which could indicate a case of convergence. 

Most characters present a moderate yet significant phylogenetic signal, and predominantly support BM models, indicating a history of neutral constant divergence. Total nematocyst volume and cnidoband-to-heteroneme length ratio showed strongly conserved phylogenetic signals. These characters may be useful for taxonomic purposes.
Bayesian Analysis of Macroevolutionary Mixtures [@rabosky2014bamm] identified evolutionary rate regime shifts in the branches leading to the euphysonects, to clade B, and to Cordagalma for several characters. These shifts could be associated with adaptive responses to dietary change.

```{r load_tree, include=F}
#Load tree
#consensus = ape::read.tree("concatenate.fasta.contree")
#consensus = read.nexus("gene_map_ct.tre")
consensus = read.nexus("TimeTree_CT_truerho.tre") %>% drop.tip(56:61)
#consensus = reroot(consensus,103)
#consensus = reroot(consensus,97)
#consensus = drop.tip(consensus, c(28,29,30,59:61))
#consensus = drop.tip(consensus, c(56:61))
consensus$tip.label = str_replace_all(consensus$tip.label,"_"," ")
#Switch nanomia_bijuga for sp
consensus$tip.label[which(consensus$tip.label == "Nanomia bijuga")] <- "Nanomia sp"

#Prune quant matrix to tree species
matrix = castnumbers[which(!is.na(castnumbers$Species)),]
matrix_logs = castlogs[which(!is.na(castlogs$Species)),]
sharedspp = matrix$Species[which(matrix$Species %in% consensus$tip.label)]
sharedmatrix = matrix[which(matrix$Species %in% sharedspp),]
sharedlogs = matrix_logs[which(matrix$Species %in% sharedspp),]
sharedmeans = castmeans[which(castmeans$Species %in% sharedspp),]
sharedmean_logs = castmean_logs[which(castmean_logs$Species %in% sharedspp),]
sharedvars = castvariances[which(castvariances$Species %in% sharedspp),]
sharedvar_logs = castvariance_logs[which(castvariance_logs$Species %in% sharedspp),]
#sharedmeans = solidSPPmeans[which(solidSPPmeans$Species %in% sharedspp),]
#sharedvars = solidSPPvars[which(solidSPPvars$Species %in% sharedspp),]

#Prune categorical matrix to tree species
cat_rowNAs = apply(categorical[,-1], 1, function(x) sum(is.na(x)))
catmatrix = categorical[which(cat_rowNAs<1),] %>% .[,-1]
sharedspp_cat = rownames(catmatrix)[which(rownames(catmatrix) %in% consensus$tip.label)]
sharedcategorical = catmatrix[which(rownames(catmatrix) %in% sharedspp_cat),]

#Prune tree to quant matrix species
nodatatipnames = consensus$tip.label[which(!(consensus$tip.label %in% sharedmatrix$Species))]
nodatatips = c(1:length(consensus$tip.label))[which(consensus$tip.label %in% nodatatipnames)]
prunedtree = drop.tip(consensus, nodatatips)
prunedtree$tip.label
plot(prunedtree)

#ultram = chronos(prunedtree)
ultram = prunedtree
plot(ultram)

##Make the pseudoindividuals tree
# newtree = ultram
# sharedmatrix_plied = sharedmatrix
# sharedmatrix_plied$slide_id = paste(sharedmatrix$slide_id, sharedmatrix$Species, sep = "_")
# for (i in 1:nrow(sharedmatrix_plied)) {
#   pos = which(newtree$tip.label == sharedmatrix_plied$Species[i])
#   print(pos)
#   newtree = bind.tip(newtree, sharedmatrix_plied$slide_id[i], where = pos, edge.length = 0.1)
#   print(newtree$tip.label)
#   newtree$tip.label = str_replace_all(newtree$tip.label,'_',' ')
# }
# inditree = drop.tip(newtree, which(!grepl(".[0-9].*", newtree$tip.label)))
# zerotipTree = inditree
# inditree$edge.length[inditree$edge.length==0] <- 0.0000000001
# shavedtree = inditree
# #inditree = chronos(inditree)
# plot(inditree)
# sharedmatrix_plied$slide_id = str_replace_all(sharedmatrix_plied$slide_id,'_',' ')
# sharedmatrix = sharedmatrix_plied[match(sharedmatrix_plied$slide_id, inditree$tip.label),]
# rownames(sharedmatrix) <- 1:nrow(sharedmatrix)

#Prune tree to categorical matrix species
nodatatipnames_cat = consensus$tip.label[which(!(consensus$tip.label %in% sharedspp_cat))]
nodatatips_cat = c(1:length(consensus$tip.label))[which(consensus$tip.label %in% nodatatipnames_cat)]
cat_tree = drop.tip(consensus, nodatatips_cat)
cat_tree$tip.label
plot(cat_tree)
#ultram_cat = chronos(cat_tree)
ultram_cat = cat_tree
plot(ultram_cat)
sharedcategorical = sharedcategorical[match(ultram_cat$tip.label, rownames(sharedcategorical)),]
cprunedmatrix = sharedcategorical[which(rownames(sharedcategorical)%in%rownames(sharedmatrix)),] %>% .[which(sapply(.,function(x) length(unique(x)))>1)]
sharedbinary = sharedcategorical
sharedbinary$Haploneme.type = as.character(sharedbinary$Haploneme.type)
sharedbinary[sharedbinary=="Isorhizas"] = 0
sharedbinary[sharedbinary=="Anisorhizas"] = 1
sharedbinary$Haploneme.type = as.numeric(sharedbinary$Haploneme.type)
sharedbinary$Heteroneme.type = as.character(sharedbinary$Heteroneme.type)
sharedbinary[sharedbinary=="Stenotele"] = 0
sharedbinary[sharedbinary=="Microbasic mastigophore"] = 1
sharedbinary[sharedbinary=="Eurytele"] = NA
sharedbinary$Heteroneme.type = as.numeric(sharedbinary$Heteroneme.type)

#purely numerics
Q_sharedmatrix = sharedmatrix[,c(-1,-2,-3)]
rownames(sharedmeans) = sharedmeans$Species
Q_sharedmeans = sharedmeans[,-1]
rownames(sharedvars) = sharedvars$Species
Q_sharedvars = sharedvars[,-1]
Q_sharedmean_logs = sharedmean_logs[,-1]
rownames(Q_sharedmean_logs) = sharedmean_logs$Species

```

Novel phylogenetic relationships:
-Erenna spp closely related to Stephanomia

1.0 Table showing for each species the mean, number of individuals measured, and standard error of every character, ordered by cnidomic index / tentillum size, and/or colored by clade.

```{r export_table_morph, include=TRUE}
Ses = castSE[,-1]
Ses[Ses == 0] = NA
morphdata = cbind(castN, castmeans[,-1], Ses)
morphdata = morphdata[,c(1:3,33,4,34,5,35,6,36,7,37,8,38,9,39,10,40,11,41,12,42,13,43,14,44,15,45,16,46,17,47,18,48,19,49,20,50,21,51,22,52,23,53,24,54,25,55,26,56,27,57,28,58,29,59,30,60,31,61,32,62)]
names(morphdata) = str_replace_all(names(morphdata),".1","_SE")

write.csv(morphdata, "characterdata.csv")

#Make a heatmap
heatdata = as.matrix(castmean_logs[,-1])
rownames(heatdata) = castmean_logs$Species
heatdata[is.nan(heatdata)]<- -1
hcolors = white2blue(19)
hcolors<-c(rep("#000000FF",10), hcolors)
heatmap(heatdata, scale = "column", cexCol = 0.2, col=hcolors, keep.dendro = T)


```


```{r phylosignals}
phylosignals = as.data.frame(matrix(ncol=3, nrow=ncol(sharedmean_logs[,-1])))
#phylosignals = as.data.frame(matrix(ncol=3, nrow=ncol(sharedmeans[,-1])))
names(phylosignals) = c("K", "P", "Ntaxa")
for(i in 2:ncol(sharedmean_logs)){
  CH_I=as.numeric(sharedmean_logs[,i])
  #CH_I=as.numeric(sharedmeans[,i])
  names(CH_I) = sharedmean_logs$Species
  #names(CH_I) = sharedmeans$Species
  SE_I = as.numeric(castSE[,i]) %>% log()
  SE_I[which(SE_I==-Inf)] = 0
  names(SE_I) = castSE$Species
  CH_I= CH_I[!is.na(CH_I)]
  SE_I= SE_I[!is.na(SE_I)]
  SE_I = SE_I[which(names(SE_I)%in%names(CH_I))]
  CH_I = CH_I[which(names(CH_I)%in%names(SE_I))]
  treeI = drop.tip(ultram,which(!(ultram$tip.label %in% names(CH_I))))
  class(treeI) = "phylo"
  #print(names(sharedmeans)[i]);print(phylosig(treeI, CH_I, se = SE_I, test=T) %>% .[c("K","P")])
  rownames(phylosignals)[i-1] <- names(sharedmean_logs)[i]
  PSIG <- phylosig(treeI, CH_I, se = SE_I, test=T)
  phylosignals[i-1,1] <- PSIG$K
  phylosignals[i-1,2] <- PSIG$P
  phylosignals[i-1,3] <- length(CH_I)
  phylosignals$K = round(phylosignals$K,3)
}
#write.csv(phylosignals, "PhylosignalsWSE_log.csv")
```


1.2 Table showing the best AICc supported model generating the data for each character and its AICc score. Model adequacy. Phylogenetic signals.

```{r fitContinuous, include=F}
#Model support
  AICdf = as.data.frame(matrix(ncol=6,nrow=ncol(Q_sharedmean_logs)))
  colnames(AICdf) = c("Variable", "white_noise", "starBM", "BM", "EB", "OU")
  for(c in 1:ncol(Q_sharedmean_logs)){
    startree <- rescale(ultram, "lambda", 0)
    C = Q_sharedmean_logs[,c]
    names(C) = rownames(Q_sharedmean_logs)
    C = C[!is.na(C)]
    Ctree = drop.tip(ultram, which(!(ultram$tip.label %in% names(C))))
    startree = drop.tip(startree, which(!(startree$tip.label %in% names(C))))
    Cse = castSE[,c+1] %>% log() %>% abs()
    Cse[which(Cse == Inf)] <- 0
    names(Cse) = castSE$Species
    Cse = Cse[which(names(Cse) %in% names(C))]
    model_matrix = matrix("NA", nrow = 5, ncol = 3)
    colnames(model_matrix) = c("aicc","aicc_best","dAICc")
    row.names(model_matrix) = c("white", "starBM", "BM", "EB", "OU")
    for(j in 1:dim(model_matrix)[1]){
      if(j==2){
        temp_model = fitContinuous(startree, C, model="BM", SE = Cse)$opt
      }
      else{
        temp_model = fitContinuous(Ctree, C, model=row.names(model_matrix)[j], SE = Cse)$opt
      }
      model_matrix = apply(model_matrix,2, as.numeric)
      row.names(model_matrix) = c("white", "starBM", "BM", "EB", "OU")
      model_matrix[j, "aicc"] <- temp_model$aicc
    }
    model_matrix[,"aicc_best"] <- min(model_matrix[,"aicc"])
    model_matrix[,"dAICc"] <- model_matrix[, "aicc"] - model_matrix[j, "aicc_best"]
    print(names(Q_sharedmean_logs)[c])
    string_c <- c(names(Q_sharedmean_logs)[c], model_matrix[,3])
    names(string_c) = colnames(AICdf)
    AICdf[c,] <- string_c
  }
  AICdf[,2:6] = apply(AICdf[,2:6], 2, as.numeric) %>% apply(2, round3)
  #write.csv(AICdf, "log_model_support.csv")
  
#Model adequacy
  worthy_models = AICdf[which(AICdf$white_noise != 0 & AICdf$starBM != 0),]
  MAD = as.data.frame(matrix(ncol = 6, nrow = nrow(worthy_models)))
  names(MAD) = c("msig", "cvar", "svar", "sasr", "shgt", "dcfd")
  rownames(MAD) = worthy_models$Variable
  for(m in 1:nrow(worthy_models)){
    C = Q_sharedmean_logs[,which(names(Q_sharedmean_logs) == worthy_models$Variable[m])]
    names(C) = rownames(Q_sharedmean_logs)
    C = C[!is.na(C)]
    Ctree = drop.tip(ultram, which(!(ultram$tip.label %in% names(C))))
    C = C[match(Ctree$tip.label, names(C))]
    class(Ctree)="phylo"
    FC <- fitContinuous(Ctree,C,model=worthy_models$Best_model[m])
    UTC <- make_unit_tree(FC)
    picstat_data <- calculate_pic_stat(UTC)
    sim <- simulate_char_unit(UTC)
    picstat_sim <- calculate_pic_stat(sim)
    compare_pic_stat(picstat_data, picstat_sim) %>% .$p.values -> MAD[m,]
  }
  phy_models = data.frame(worthy_models,MAD)
  phy_models[,7:12] = apply(phy_models[,7:12], 2,round3)
  #write.csv(phy_models, "model_adequacy.csv")
```

Testing nematocyst shape evolution questions:
```{r elongation}
het_el = sharedmean_logs$heteroneme_elongation
names(het_el) = sharedmean_logs$Species
hap_el = sharedmean_logs$haploneme_elongation
names(hap_el) = sharedmean_logs$Species

###
cysthets = c(0,0,0)
names(cysthets) = c("Physalia physalis", "Rhizophysa eysenhardtii", "Rhizophysa filiformis")
het_el = c(het_el, cysthets)
###
het_el = het_el[which(!is.na(het_el))]
hap_el = hap_el[which(!is.na(hap_el))]
het_tree = drop.tip(ultram, which(!(ultram$tip.label %in% names(het_el))))
hap_tree = drop.tip(ultram, which(!(ultram$tip.label %in% names(hap_el))))
Phenogram(het_tree, het_el)
Phenogram(hap_el, as.data.frame(hap_el), hap_tree)

hap_el = hap_el[which(names(hap_el) %in% names(het_el))]
het_el = het_el[which(names(het_el) %in% names(hap_el))]
het_el = het_el[match(names(hap_el), names(het_el))]
elon_data = cbind(het_el, hap_el) %>% as.data.frame()
names(elon_data) = c("Heteroneme elongation (log um)", "Haploneme elongation (log um)")
elon_tree = drop.tip(ultram, which(!(ultram$tip.label %in% names(hap_el))))
phylomorphospace(elon_tree, elon_data, label="horizontal")


```

1.3 Figure showing major categorical character shifts, gains, and losses on a simplified phylogeny.

```{r simmaps, include=F}
par(ask=F)
tentilla = sharedcategorical$Tentilla
names(tentilla) = rownames(sharedcategorical)
prox_het = sharedcategorical$Proximal.heteronemes
names(prox_het) = rownames(sharedcategorical)
desmo = sharedcategorical$Desmonemes
names(desmo) = rownames(sharedcategorical)
rhopalo = sharedcategorical$Rhopalonemes
names(rhopalo) = rownames(sharedcategorical)
dyn_cnido = sharedcategorical$Dynamic.cnidoband
names(dyn_cnido) = rownames(sharedcategorical)
elastic = sharedcategorical$Elastic.strand
names(elastic) = rownames(sharedcategorical)
distal_desmo = sharedcategorical$Distal.cnidoband.desmonemes
names(distal_desmo) = rownames(sharedcategorical)
coiled = sharedcategorical$Coiled.tentilla
names(coiled) = rownames(sharedcategorical)
heterotype = sharedcategorical$Heteroneme.type
heterotype=as.character(heterotype)
names(heterotype) = rownames(sharedcategorical)
haplotype = sharedcategorical$Haploneme.type
haplotype=as.character(haplotype)
names(haplotype) = rownames(sharedcategorical)

Simmap_list = list()
###SIMMAP Tentilla:
make.simmap(ultram_cat, tentilla, nsim = 100) -> tentilla_sim
Simmap_list[[1]] <- tentilla_sim
plotTree(ultram_cat, lwd = 4)
tentilla_sim %>% plotSimmap(lwd = 4, add = T)
colors = c("black", "red")
names(colors) = c("Present", "Absent")
nodelabels(pie=(describe.simmap(tentilla_sim, plot=F)$ace) ,piecol=colors,cex=0.35)
add.simmap.legend(colors = colors, x=0.6*par()$usr[1],y=0.3*par()$usr[4],prompt=FALSE)
densityMap(tentilla_sim)

###SIMMAP Proximal Heteronemes:
make.simmap(ultram_cat, prox_het, nsim = 100) -> prox_het_sim
Simmap_list[[2]] <- prox_het_sim
plotTree(ultram_cat, lwd = 4)
prox_het_sim %>% plotSimmap(lwd = 4, add = T)
colors = c("black", "red")
names(colors) = c("Present", "Absent")
nodelabels(pie=(describe.simmap(prox_het_sim, plot=F)$ace) ,piecol=colors,cex=0.35)
add.simmap.legend(colors = colors, x=0.6*par()$usr[1],y=0.3*par()$usr[4],prompt=FALSE)
densityMap(prox_het_sim)

###SIMMAP Desmonemes:
make.simmap(ultram_cat, desmo, nsim = 100) -> desmo_sim
Simmap_list[[3]] <- desmo_sim
plotTree(ultram_cat, lwd = 4)
desmo_sim %>% plotSimmap(lwd = 4, add = T)
colors = c("black", "red")
names(colors) = c("Absent", "Present")
nodelabels(pie=(describe.simmap(desmo_sim, plot=F)$ace) ,piecol=colors,cex=0.35)
add.simmap.legend(colors = colors, x=0.6*par()$usr[1],y=0.3*par()$usr[4],prompt=FALSE)
densityMap(desmo_sim)

###SIMMAP Rhopalonemes:
make.simmap(ultram_cat, rhopalo, nsim = 100) -> rhopalo_sim
Simmap_list[[4]] <- rhopalo_sim
plotTree(ultram_cat, lwd = 4)
rhopalo_sim %>% plotSimmap(lwd = 4, add = T)
colors = c("black", "red")
names(colors) = c("Absent", "Present")
nodelabels(pie=(describe.simmap(rhopalo_sim, plot=F)$ace) ,piecol=colors,cex=0.35)
add.simmap.legend(colors = colors, x=0.6*par()$usr[1],y=0.3*par()$usr[4],prompt=FALSE)
densityMap(rhopalo_sim)

###SIMMAP Dynamic Cnidoband:
make.simmap(ultram_cat, dyn_cnido, nsim = 100) -> dyn_cnido_sim
Simmap_list[[5]] <- dyn_cnido_sim
plotTree(ultram_cat, lwd = 4)
dyn_cnido_sim %>% plotSimmap(lwd = 4, add = T)
colors = c("black", "red")
names(colors) = c("Absent", "Present")
nodelabels(pie=(describe.simmap(dyn_cnido_sim, plot=F)$ace) ,piecol=colors,cex=0.35)
add.simmap.legend(colors = colors, x=0.6*par()$usr[1],y=0.3*par()$usr[4],prompt=FALSE)
densityMap(dyn_cnido_sim)

###SIMMAP Elastic Strand:
make.simmap(ultram_cat, elastic, nsim = 100) -> elastic_sim
Simmap_list[[6]] <- elastic_sim
plotTree(ultram_cat, lwd = 4)
elastic_sim %>% plotSimmap(lwd = 4, add = T)
colors = c("black", "red")
names(colors) = c("Absent", "Present")
nodelabels(pie=(describe.simmap(elastic_sim, plot=F)$ace) ,piecol=colors,cex=0.35)
add.simmap.legend(colors = colors, x=0.6*par()$usr[1],y=0.3*par()$usr[4],prompt=FALSE)
densityMap(elastic_sim)

###SIMMAP Distal CB Desmonemes:
make.simmap(ultram_cat, distal_desmo, nsim = 100) -> distal_desmo_sim
Simmap_list[[7]] <- distal_desmo_sim
plotTree(ultram_cat, lwd = 4)
distal_desmo_sim %>% plotSimmap(lwd = 4, add = T)
colors = c("black", "red")
names(colors) = c("Absent", "Present")
nodelabels(pie=(describe.simmap(distal_desmo_sim, plot=F)$ace) ,piecol=colors,cex=0.35)
add.simmap.legend(colors = colors, x=0.6*par()$usr[1],y=0.3*par()$usr[4],prompt=FALSE)
densityMap(distal_desmo_sim)

###SIMMAP Tentilla Coiledness:
make.simmap(ultram_cat, coiled, nsim = 100) -> coiled_sim
Simmap_list[[8]] <- coiled_sim
plotTree(ultram_cat, lwd = 4)
coiled_sim %>% plotSimmap(lwd = 4, add = T)
colors = c("black", "red")
names(colors) = c("Absent", "Present")
nodelabels(pie=(describe.simmap(coiled_sim, plot=F)$ace) ,piecol=colors,cex=0.35)
add.simmap.legend(colors = colors, x=0.6*par()$usr[1],y=0.3*par()$usr[4],prompt=FALSE)
densityMap(coiled_sim)

###SIMMAP Heteroneme type:
heterotype = heterotype[heterotype!=""]
HTtree = drop.tip(ultram_cat, which(!(ultram_cat$tip.label %in% names(heterotype))))
make.simmap(HTtree, heterotype, nsim = 100) -> heterotype_sim
Simmap_list[[9]] <- heterotype_sim
plotTree(HTtree, lwd = 4)
heterotype_sim %>% plotSimmap(lwd = 4, add = T)
colors = c("black", "red", "green")
names(colors) = c("Eurytele", "Microbasic mastigophore", "Stenotele")
nodelabels(pie=(describe.simmap(heterotype_sim, plot=F)$ace) ,piecol=colors,cex=0.35)
add.simmap.legend(colors = colors, x=0.6*par()$usr[1],y=0.3*par()$usr[4],prompt=FALSE)

###SIMMAP Haploneme type:
haplotype = haplotype[haplotype!=""]
HTtree = drop.tip(ultram_cat, which(!(ultram_cat$tip.label %in% names(haplotype))))
make.simmap(HTtree, haplotype, nsim = 100) -> haplotype_sim
Simmap_list[[10]] <- haplotype_sim
plotTree(HTtree, lwd = 4)
haplotype_sim %>% plotSimmap(lwd = 4, add = T)
colors = c("black", "red")
names(colors) = c("Isorhizas", "Anisorhizas")
nodelabels(pie=(describe.simmap(haplotype_sim, plot=F)$ace) ,piecol=colors,cex=0.35)
add.simmap.legend(colors = colors, x=0.6*par()$usr[1],y=0.3*par()$usr[4],prompt=FALSE)
densityMap(haplotype_sim)



```


2 -- COMPARATIVE ANALYSES
2.0 Confusion matrix table showing PIC_correlations and trait correlation R2 and p-values for each pair of continuous characters.

```{r character_correlations, include=FALSE}
#PIC correlations with Rphylip
#C = sharedlogs[,c(-1,-3)] %>% .[which(!is.na(rowSums(.[,-1]))),]
C = sharedmatrix[,c(-1,-3)] %>% .[which(!is.na(rowSums(.[,-1]))),]
Cspecies = C$Species %>% as.character()
C = as.matrix(C[,-1])
rownames(C) = Cspecies
Ctree = drop.tip(ultram,which(!(ultram$tip.label %in% rownames(C))))
class(Ctree) = "phylo"
PICi = Rcontrast(tree=Ctree, X=C, path="phylip-3.695/exe", cleanup=TRUE)

#Correlation visualizations R2
phy_corr = PICi$VarA.Correlations
intra_corr = PICi$VarE.Correlations
phy_corr[upper.tri(phy_corr)] <- NA
combicorr = phy_corr
combicorr[upper.tri(combicorr)] = intra_corr[upper.tri(intra_corr)]
rownames(combicorr) = colnames(C)
colnames(combicorr) = colnames(C)
corrplot(combicorr, diag=F, tl.cex = 0.4, tl.col="black") #phylo correlations vs intraspecific correlations
PICOLS = combicorr
PICOLS[upper.tri(PICOLS)]=cor(C)[upper.tri(cor(C))]
corrplot(PICOLS, diag=F, tl.cex = 0.4, tl.col="black") #phylo correlations vs regular correlations

cbind(as.vector(phy_corr), as.vector(cor(C))) %>% as.data.frame()->phyreg
names(phyreg)<-c("Phylo", "Reg")
ggplot(phyreg, aes(x=Reg, y=Phylo, color=(Phylo+Reg)/2)) + geom_point() + geom_hline(yintercept = 0)  + geom_vline(xintercept = 0) + theme_bw()
abline(h=0)
abline(v=0)

#Change directionalities
changes = matrix(ncol=ncol(sharedmean_logs)-1, nrow=nrow(ultram$edge))
for(ch in 2:ncol(sharedmean_logs)){
  X=as.numeric(sharedmean_logs[,ch])
  names(X) = sharedmean_logs$Species
  X=X[!is.na(X)]
  treeI = drop.tip(ultram,which(!(ultram$tip.label %in% names(X))))
  class(treeI) = "phylo"
  #changes = c()
  tips = X
  names(tips)=match(names(X), treeI$tip.label)
  faX = c(anc.ML(treeI,X)$ace,tips)
  edges = treeI$edge
  for(i in 1:nrow(edges)){
    node_old = edges[i,1]
    node_new = edges[i,2]
    (faX[which(names(faX) == node_new)] - faX[which(names(faX) == node_old)])-> changes[i,ch-1]
  }
  hist(changes)
  abline(v=0,col="red")
}

#Categorical-Continuous correlations
catlogits = data.frame(matrix(ncol = 6, nrow = 0))
names(catlogits) = c("Character binary", "Character continuous", "Ntaxa", "phyloglmAIC", "phyloglmP","phyloglm_b")
catlogits[1,]=rep(1,6)
binary=categorical[,2:9]
for(cat in 1:ncol(binary)){
  for(char in 2:ncol(sharedmean_logs)){
    CH_J=binary[,cat]
    names(CH_J) = rownames(binary)
    CH_J = CH_J[!is.na(CH_J)]
    CH_I = sharedmean_logs[,char]
    names(CH_I) = sharedmean_logs$Species
    CH_I = CH_I[!is.na(CH_I)]
    CH_J = CH_J[which(names(CH_J)%in%names(CH_I))]
    CH_I = CH_I[which(names(CH_I)%in%names(CH_J))]
    treeIJ = drop.tip(ultram, which(!(ultram$tip.label %in% names(CH_J))))
    CH_I = CH_I[match(treeIJ$tip.label, names(CH_I))]
    CH_J = CH_J[match(treeIJ$tip.label, names(CH_J))]
    datIJ = data.frame(char_cat = CH_J, char_con = CH_I)
    if(length(unique(CH_J))>1){
      phylogit = phyloglm(char_cat~char_con,phy=treeIJ,data=datIJ,boot=10, btol=20)
      print(phylogit)
      rowIJ = c(names(binary)[cat], names(sharedmean_logs)[char], phylogit$n, phylogit$aic, coef(summary(phylogit))[2,6], coef(summary(phylogit))[2,1])
      } else{
      rowIJ = c(names(binary)[cat], names(sharedmean_logs)[char], phylogit$n, NA, NA, NA)
      }
    #print(rowIJ)
    catlogits = rbind(catlogits, rowIJ)
    print(catlogits[nrow(catlogits),])
  }
}
catlogits = catlogits[-1,]
catlogits[,4:6] = sapply(catlogits[,4:6], as.numeric)
catlogits[,4:6] = sapply(catlogits[,4:6], function(x){round(x,3)})
write.csv(catlogits, "catlogits.csv", row.names = F)


```


2.1 Table showing the model parameters for each significant regression.


2.3 Verbally PCA and phylogenetic PCA/PICVarA_PCA of the characters. Phylomorphospace superimposed to the tip coordinates in PC1--PC2.


```{r PCA}
par(mar=rep(3,4), mfrow=c(1,1))
raw_matrix = Q_sharedmean_logs[,c(1:2,4:20)] %>% .[which(!is.na(rowSums(.))),]
raw_matrix_notf = Q_sharedmean_logs[,c(1:2,4:20)] %>% .[,c(1:7,12:17)] %>% .[which(!is.na(rowSums(.))),]

compound_matrix = Q_sharedmean_logs[which(!is.na(rowSums(Q_sharedmean_logs))),c(3,21:30)]
#raw_tree = drop.tip(ultram, which(!(ultram$tip.label %in% rownames(raw_matrix))))
raw_tree = drop.tip(ultram, which(!(ultram$tip.label %in% rownames(raw_matrix_notf))))
compound_tree = drop.tip(ultram, which(!(ultram$tip.label %in% rownames(compound_matrix))))

#Regular PCA on means log
  ##Raw characters
#PCA(raw_matrix) -> Pca_raw
PCA(raw_matrix_notf) -> Pca_raw
Pca_raw %>% fviz_contrib(choice="var", axes=1, sort.val="desc")
Pca_raw %>% fviz_contrib(choice="var", axes=2, sort.val="desc")
Pca_raw %>% fviz_pca_biplot( col.var="contrib", gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"), repel = TRUE)
Pca_raw %>% fviz_pca_biplot(axes=c(3,4), col.var="contrib", gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"), repel = TRUE)
phylomorphospace(tree=raw_tree, Pca_raw$ind$coord[,1:2], label = "horizontal", xlab = "PC1", ylab = "PC2")
phylomorphospace(tree=raw_tree, Pca_raw$ind$coord[,3:4], label = "horizontal", xlab = "PC3", ylab = "PC4")
physignal(Pca_raw$ind$coord[,2], raw_tree)
multiPhylosignal(Pca_raw$ind$coord, raw_tree)
phylosignal(Pca_raw$ind$coord[,1], raw_tree)
  ##Morphometric characters
PCA(compound_matrix) -> Pca_compound
Pca_compound %>% fviz_contrib(choice="var", axes=1, sort.val="desc")
Pca_compound %>% fviz_contrib(choice="var", axes=2, sort.val="desc")
Pca_compound %>% fviz_pca_biplot( col.var="contrib", gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"), repel = TRUE)
Pca_compound %>% fviz_pca_biplot(axes=c(3,4), col.var="contrib", gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"), repel = TRUE)
phylomorphospace(tree=compound_tree, Pca_compound$ind$coord[,1:2], label = "horizontal", xlab = "PC1", ylab = "PC2")
phylomorphospace(tree=compound_tree, Pca_compound$ind$coord[,3:4], label = "horizontal", xlab = "PC3", ylab = "PC4")
physignal(Pca_compound$ind$coord, compound_tree)
multiPhylosignal(Pca_compound$ind$coord, compound_tree)

#PhyloPCA on means
raw_tree = drop.tip(ultram, which(!(ultram$tip.label %in% rownames(raw_matrix))))
PPCA_raw = phyl.pca(raw_tree, raw_matrix)
PPCA_compound = phyl.pca(compound_tree, compound_matrix)
PPCA_raw %>% biplot(main=paste(signif(summary(PPCA_raw)$importance[2,1]*100,3),"%"), ylab=paste(signif(summary(PPCA_raw)$importance[2,2]*100,3),"%"), cex = .6, expand =1)
PPCA_compound %>% biplot(main=paste(signif(summary(PPCA_compound)$importance[2,1]*100,3),"%"), ylab=paste(signif(summary(PPCA_compound)$importance[2,2]*100,3),"%"), cex = .6, expand =0.4)
phylomorphospace(raw_tree, PPCA_raw$S)

#Plot mirror trees QUANT
X = sharedmean_logs$coiledness
names(X) = sharedmean_logs$Species
X = X[!is.nan(X)]
Y = sharedmean_logs$Involucrum.length..um.
names(Y) = sharedmean_logs$Species
Y = Y[!is.nan(Y)]
Y = Y[which(names(Y) %in% names(X))]
X = X[which(names(X) %in% names(Y))]
XYtree = drop.tip(ultram, which(!(ultram$tip.label %in% names(X))))
class(XYtree) = "phylo"
layout(matrix(1:3,1,3),widths=c(0.44,0.12,0.44))
par(cex=0.5)
#pdf("deliverables/Hvol_copepod.pdf",width=10,height=6)
OX = contMap(XYtree,X,sig=1,legend=1, plot = F, outline = F)
OX$cols[1:length(OX$cols)] = colorRampPalette(c("yellow","purple"), space="Lab")(length(OX$cols))
plot(OX,ftype="off")
ylim<-c(1-0.12*(length(XYtree$tip.label)-1),length(XYtree$tip.label))
plot.new(); plot.window(xlim=c(-0.1,0.1),ylim=ylim)
text(rep(0,length(XYtree$tip.label)), 1:length(XYtree$tip.label),XYtree$tip.label)
OY = contMap(XYtree,Y, sig=1,legend=1, plot = F,  outline = F)
OY$cols[1:length(OY$cols)] = colorRampPalette(c("green","red"), space="Lab")(length(OY$cols))
plot(OY, direction="leftwards", ftype = "off")

```

2.4 Table showing BAMM-analyzed number of regime shifts in the rates of evolution of each character.



```{r BAMM}
traitlist = list()
for(i in 2:ncol(sharedmean_logs)){
  traitlist[[i]] <- sharedmean_logs[,c(1,i)]
  names(traitlist)[i] = names(sharedmean_logs)[i]
}

traitlist <- lapply(traitlist, function(x){x<-x[which(!is.nan(x[,2])),]})

for(i in 2:length(traitlist)){
  treei = drop.tip(ultram, which(!(ultram$tip.label %in% traitlist[[i]]$Species)))
  treei$tip.label = str_replace_all(treei$tip.label, " ", "_")
  write.tree(treei, file = paste("BAMM/",names(traitlist[[i]])[2], "_tree.tre", sep=""))
}

for(i in 2:length(traitlist)){
  traitlist[[i]]$Species = str_replace_all(traitlist[[i]]$Species, " ", "_")
  write.table(traitlist[[i]],file = paste("BAMM/",names(traitlist[[i]])[2], ".txt", sep=""), sep="\t", col.names = F, row.names = F, quote = F)
}

#PGLS with other data
BAMMtree <- read.tree("BAMM/Cnidoband.free.length..um._tree.tre")
# ESS after 20% burnin
mcmcout <- read.csv("BAMM/Cnidoband_free_length/mcmc_out.txt")
burnstart <- floor(0.2*nrow(mcmcout))
postburn <- mcmcout[burnstart:nrow(mcmcout), ]
#effectiveSize(postburn$N_shifts)
#effectiveSize(postburn$logLik)

```

Out of 29 characters, 11 did  not significantly (delta AICc > 2) support a phylogenetic model. From the remaining 18, Brownian Motion was supported for 17 of them. Only haploneme nematocyst length had uniequivocal support for Early Burst.

3 -- RELATIONSHIPS WITH DIET / FUNCTION / Hypothesis testing

```{r diet_data, include=F}
#Retrieve diet info from literature BINARY
GC = read.csv("Cmerged.csv", header = T, sep=',')[,c(2,4,5,6)] %>% .[which(grepl("diet",.$character) & .$state==1),]
GC$character = factor(GC$character, levels=unique(GC$character))
GC$species = as.character(GC$species)
GC$species[which(GC$species == "Nanomia bijuga")] <- "Nanomia sp"
GC$species[which(GC$species == "Rhizophysa eyesenhardti")] <- "Rhizophysa eysenhardtii"
GC$species[which(GC$species == "Agalma okeni")] <- "Agalma okenii"
GC = GC[which(GC$species %in% ultram$tip.label),]
GC = split(GC,GC$character)
nrowGC = purrr::map(GC,nrow) %>% as.numeric()
GC = GC[which(nrowGC>2)]
GC = purrr::map(GC,unique)
diet= matrix(ncol=length(GC),nrow=length(unique(sharedmeans$Species))) %>% as.data.frame()
names(diet) = names(GC)
rownames(diet) = unique(sharedmeans$Species)
for(E in GC){
  print(E$species)
  for(S in E$species){
    diet[which(rownames(diet) == S),as.character(unique(E$character))] = 1
  }
}
diet[is.na(diet)] <- 0
diet = diet[which(rowSums(diet)>0),which(colSums(diet)<nrow(diet))]
#Add hypothesized diet from personal observations of the authors
cladeB <- matrix(rep(c(0,1,0,0,0,0,0,0,0,0),3),nrow=10, ncol = 3) %>% t() %>% as.data.frame()
rownames(cladeB) = c("Erenna richardi", "Erenna sirena", "Stephanomia amphytridis")
krilleaters = matrix(rep(c(0,0,0,1,0,0,1,0,0,0),4),nrow=10, ncol = 4) %>% t() %>% as.data.frame()
rownames(krilleaters) = c("Praya dubia", "Resomia ornicephala", "Lychnagalma utricularia", "Bargmannia amoena")
Gelatinous_diet = rep(0,nrow(diet))
diet = cbind(diet, Gelatinous_diet)
names(diet)[ncol(diet)] = "Gelatinous diet"
gelateaters = matrix(rep(c(0,0,0,0,0,0,0,0,0,1),1),nrow=10, ncol = 1) %>% t() %>% as.data.frame()
names(gelateaters) = names(diet)
rownames(gelateaters) = c("Apolemia rubriversa")
names(gelateaters)=names(diet)
names(krilleaters)=names(diet)
names(cladeB)=names(diet)
diet = rbind(diet, cladeB, krilleaters, gelateaters)
#rownames(diet)[12] = 'Erenna richardi'
dprunedmatrix = sharedmeans[which(sharedmeans$Species%in%rownames(diet)),]
dprunedmatrix_logs = sharedmean_logs[which(sharedmean_logs$Species%in%rownames(diet)),]
dprunedTree = drop.tip(ultram, which(!(ultram$tip.label %in% rownames(diet))))
plot(dprunedTree)

#Retrieve diet info from literature PROPORTION RELATIVE
quantDiet = read.csv("Qmerged.csv", header = T, sep=',')[,c(2,4,6)]
PP = quantDiet[which(grepl("Relative",quantDiet$character)),]
PP$character = factor(PP$character, levels=unique(PP$character))
PP$species = as.character(PP$species)
PP$species[which(PP$species == "Nanomia bijuga")] <- "Nanomia sp"
PP$species[which(PP$species == "Rhizophysa eyesenhardti")] <- "Rhizophysa eysenhardtii"
PP$species[which(PP$species == "Agalma okeni")] <- "Agalma okenii"
PP = PP[which(PP$species %in% sharedmeans$Species),]
PP = dcast(PP, species~character, value.var = "state", mean)
PP[is.na(PP)]<-0
rownames(PP) = PP$species
PP=PP[,-1]
Pprunedmatrix=sharedmeans[which(sharedmeans$Species%in%rownames(PP)),]
Pprunedmatrix_logs = sharedmean_logs[which(sharedmean_logs$Species%in%rownames(PP)),]
Pprunedtree = drop.tip(ultram, which(!(ultram$tip.label %in% rownames(PP))))
plot(Pprunedtree)

selectivity = read.csv("PurcellSiphonophoresDiet.csv", header=T, sep=",")[,c(1,31:39)]
selectivity$Species <- as.character(selectivity$Species)
selectivity$Species[which(selectivity$Species == "Nanomia bijuga")] <- "Nanomia sp"
selectivity$Species[which(selectivity$Species == "Rhizophysa eyesenhardti")] <- "Rhizophysa eysenhardtii"
selectivity = aggregate(. ~ Species, data=selectivity, FUN=mean)
rownames(selectivity) = selectivity$Species
selectivity=selectivity[,-1]
Sprunedmatrix = sharedmeans[which(sharedmeans$Species%in%rownames(selectivity)),]
Sprunedmatrix_logs = sharedmean_logs[which(sharedmean_logs$Species%in%rownames(selectivity)),]
selectivity = selectivity[which(rownames(selectivity) %in% sharedmeans$Species),]
Sprunedtree = drop.tip(ultram, which(!(ultram$tip.label %in% rownames(selectivity))))
plot(Sprunedtree)

#Retrieve copepod prey length from literature
preylength = quantDiet[which(grepl("prey",quantDiet$character)),] %>% .[,c(1,3)]
names(preylength) = c("Species","Copepod prey length (mm)")
PL_pruned_matrix = sharedmean_logs[which(sharedmean_logs$Species %in% preylength$Species),] %>% data.frame(preylength[which(preylength$Species %in% sharedmean_logs$Species),2])
PL_pruned_SEs = sharedvar_logs[which(sharedvar_logs$Species %in% preylength$Species),] %>% data.frame(preylength[which(preylength$Species %in% sharedmean_logs$Species),2])
names(PL_pruned_matrix)[ncol(PL_pruned_matrix)] <- "Copepod prey length (mm)"
names(PL_pruned_SEs)[ncol(PL_pruned_matrix)] <- "Copepod prey length (mm)"

pGLSp_preylength = as.data.frame(matrix(nrow=ncol(PL_pruned_matrix[,-1]), ncol=1))
colnames(pGLSp_preylength) = "Copepod prey length"
row.names(pGLSp_preylength) = names(PL_pruned_matrix[,-1])
pGLS_PL_sign = pGLSp_preylength
pGLS_sign = pGLSp_preylength
for(i in 2:(ncol(PL_pruned_matrix)-1)){
  CH_I=as.numeric(PL_pruned_matrix[,i])
  names(CH_I) = PL_pruned_matrix$Species
  CH_I = CH_I[!is.na(CH_I)]
  CH_J=PL_pruned_matrix[,ncol(PL_pruned_matrix)]
  names(CH_J) = PL_pruned_matrix$Species
  CH_I = CH_I[!is.na(CH_I)]
  CH_I = CH_I[which(names(CH_I) %in% names(CH_J))]
  CH_J = CH_J[which(names(CH_J) %in% names(CH_I))]
  SE_I = PL_pruned_SEs[which(PL_pruned_SEs$Species %in% names(CH_I)),i]
  names(SE_I) = PL_pruned_SEs[which(PL_pruned_SEs$Species %in% names(CH_I)),1]
  SE_I = SE_I[match(names(CH_I), names(SE_I))]
  pgls_tree = drop.tip(ultram, which(!(ultram$tip.label %in% names(CH_I))))
  pg_data = as.data.frame(cbind(CH_I,CH_J)) %>% .[which(!is.na(rowSums(.))),]
  pgls.SEy(CH_I~CH_J, data=pg_data, tree = pgls_tree, se = SE_I) -> TTABLE
  pgls.SEy(CH_I~sample(CH_J, length(CH_J)), data=pg_data, tree = pgls_tree, se = SE_I) -> TTABLE_null
  TTABLE <- gls(CH_I ~ CH_J, correlation =  corBrownian(phy = pgls_tree), data = pg_data, method = "ML") %>% summary() %>% .$tTable %>% as.data.frame()
  TTABLE$`p-value`[2] -> pGLSp_preylength[i-1,1]
  if(pGLSp_preylength[i-1,1]<0.05){
     print(paste(rownames(pGLSp_preylength)[i-1],"Copepod prey length",pGLSp_preylength[(i-1),1],sep=" "))
     ValueIJ = TTABLE %>% .$Value %>% .[2]
     if(ValueIJ>0){pGLS_PL_sign[i-1,1] = "+"}
      else pGLS_PL_sign[i,1] = "-"
  }
}
write.csv(pGLSp_preylength, "PGLS_Pval_preylength.csv")
pGLS_PL_sign <- pGLS_PL_sign[which(rowSums(is.na(pGLS_PL_sign))!=ncol(pGLS_PL_sign)),which(colSums(is.na(pGLS_PL_sign))!=nrow(pGLS_PL_sign))]
write.csv(pGLS_PL_sign, "PGLS_SIGN_preylength.csv")
for(i in 2:ncol(PL_pruned_matrix)){
  plot(PL_pruned_matrix[,i], PL_pruned_matrix$`Copepod prey length (mm)`)
}

#Retrieve VARS data from Choy et al 2017
VARS <- read.csv("Choy2017.tsv", sep="\t")
VARS_curated = VARS[which(VARS$Pred_lowest_tax %in% ultram$tip.label | VARS$Pred_lowest_tax=="Nanomia bijuga"),]
VARS_cast = acast(VARS_curated, Pred_lowest_tax~Prey_order, fun.aggregate = length)

#Combination of VARS and GC sources
diet_VARS = rbind(diet, c(0,0,0,0,0,1,1,0,0))
diet_VARS = cbind(diet_VARS, rep(0,nrow(diet_VARS)))
rownames(diet_VARS)[nrow(diet_VARS)] <- "Lychnagalma utricularia"
names(diet_VARS)[ncol(diet_VARS)] <- "Gelatinous diet"
diet_VARS["Nanomia sp",] = c(1,0,0,0,0,1,1,1,0,1)
diet_VARS["Praya dubia",] = c(1,0,0,0,0,1,1,0,0,1)

#Soft vs Hard
soft_hard = cbind((diet$`Copepod diet`+diet$`Crustacean diet` + diet$`Decapod diet`+ diet$`Amphipod diet` + diet$`Ostracod diet`), (diet$`Fish diet`+diet$`Chaetognath diet`+diet$`Gelatinous diet`+diet$`Mollusc diet`+diet$`Polychaete diet`))
colnames(soft_hard) = c("Hard", "Soft")
rownames(soft_hard) = rownames(diet)
soft_hard <- as.data.frame(soft_hard)
soft_hard[soft_hard>0]<-1
softORhard = as.data.frame(soft_hard$Hard+soft_hard$Soft)
rownames(softORhard)=rownames(soft_hard)
names(softORhard) = "Type"
softORhard[softORhard==2]<-"Both"
softORhard[which(soft_hard$Hard==1 & soft_hard$Soft==0),]<-"Hard"
softORhard[which(soft_hard$Hard==0 & soft_hard$Soft==1),]<-"Soft"

#Nematocyst type number
nematocyst_number=as.numeric(categorical$Heteroneme.type!="")[which(!is.na(categorical$Desmonemes))]+as.numeric(categorical$Haploneme.type!="")[which(!is.na(categorical$Desmonemes))]+as.numeric(categorical$Rhopalonemes!="0")[which(!is.na(categorical$Desmonemes))]+as.numeric(categorical$Desmonemes!="0")[which(!is.na(categorical$Desmonemes))]
names(nematocyst_number)=categorical$Species[which(!is.na(categorical$Desmonemes))]
CH_J=softORhard[,1]
names(CH_J) = rownames(softORhard)
CH_J[CH_J!="Soft"]<-0
CH_J[CH_J=="Soft"]<-1
CH_I = nematocyst_number
CH_J = CH_J[which(names(CH_J)%in%names(CH_I))]
CH_I = CH_I[which(names(CH_I)%in%names(CH_J))]
treeIJ = drop.tip(ultram, which(!(ultram$tip.label %in% names(CH_J))))
CH_I = CH_I[match(treeIJ$tip.label, names(CH_I))]
CH_J = CH_J[match(treeIJ$tip.label, names(CH_J))]
datIJ = data.frame(preytype = CH_J, character = CH_I)
datIJ$preytype = as.numeric(as.character(datIJ$preytype))
logit = glm(preytype~character,data=datIJ, family="binomial")
    print(logit)
phylogit = phyloglm(preytype~character,phy=treeIJ,data=datIJ,boot=10, btol=10)
    print(phylogit)
c("Soft specilization", "Number of nematocyst types", phylogit$n, phylogit$aic, coef(summary(phylogit))[2,6], coef(summary(phylogit))[2,1], logit$aic, coef(summary(logit))[2,4], coef(summary(logit))[2,1])

#Desmoneme/Rhopaloneme vs crustacean
dprunedCat = binary[which(rownames(binary)%in% rownames(diet)),]
CH_I = dprunedCat$Rhopalonemes
names(CH_I) = rownames(dprunedCat)
CH_J = diet$`Crustacean diet`
names(CH_J) = rownames(diet)
CH_J = CH_J[which(names(CH_J)%in%names(CH_I))]
CH_I = CH_I[which(names(CH_I)%in%names(CH_J))]
treeIJ = drop.tip(ultram, which(!(ultram$tip.label %in% names(CH_J))))
CH_I = CH_I[match(treeIJ$tip.label, names(CH_I))]
CH_J = CH_J[match(treeIJ$tip.label, names(CH_J))]
fitPagel(treeIJ, CH_I, CH_J)

#Differentiated cnidobands with heteronemes
CH_I = dprunedCat$Proximal.heteronemes
names(CH_I) = rownames(dprunedCat)
CH_J = diet$`Crustacean diet`
names(CH_J) = rownames(diet)
CH_J = CH_J[which(names(CH_J)%in%names(CH_I))]
CH_I = CH_I[which(names(CH_I)%in%names(CH_J))]
treeIJ = drop.tip(ultram, which(!(ultram$tip.label %in% names(CH_J))))
CH_I = CH_I[match(treeIJ$tip.label, names(CH_I))]
CH_J = CH_J[match(treeIJ$tip.label, names(CH_J))]
fitPagel(treeIJ, CH_I, CH_J) %>% .$P

```

3.0 Phylogeny with the tips mapped with the literature dietary associations, and internal nodes showing SIMMAP reconstructed states.

```{r diet_regime_tree}
regimetree = dprunedTree
hypdiet = c("Small crustacean", "Small crustacean", "Small crustacean", "Small crustacean", "Small crustacean", "Large crustacean", "Mixed", "Mixed", "Mixed", "Large crustacean", "Large crustacean", "Mixed", "Small crustacean", "Large crustacean", "Fish", "Fish", "Fish", "Large crustacean", "Gelatinous", "Fish", "Fish", "Fish")
names(hypdiet) = regimetree$tip.label
DietAnc = ace(hypdiet, regimetree, type = "discrete")$lik.anc
HypDietAnc = 1:nrow(DietAnc)
for(row in 1:nrow(DietAnc)){
  SCR = scale(DietAnc[row,])
  print(SCR)
  HypDietAnc[row] <- rownames(SCR)[which(SCR[,1] == max(SCR[,1]))] %>% print()
}
regimetree$node.label = as.factor(HypDietAnc)
plotTree(regimetree)
nodelabels(text=regimetree$node.label,frame="none",adj=c(1.6,-0.45), cex=0.6);tiplabels(text=hypdiet, frame="none", cex=0.6, adj=c(0,2))

#SOft/Hard regime tree
SHtree = dprunedTree
hypSH = softORhard$Type[match(SHtree$tip.label,row.names(softORhard))]
names(hypSH) = SHtree$tip.label
SHAnc = ace(hypSH, SHtree, type = "discrete")$lik.anc
HypSHAnc = 1:nrow(SHAnc)
for(row in 1:nrow(SHAnc)){
  SCR = scale(SHAnc[row,])
  print(SCR)
  HypSHAnc[row] <- rownames(SCR)[which(SCR[,1] == max(SCR[,1]))] %>% print()
}
SHtree$node.label = as.factor(HypSHAnc)
plotTree(SHtree)
nodelabels(text=SHtree$node.label,frame="none",adj=c(1.6,-0.45), cex=0.6);tiplabels(text=hypSH, frame="none", cex=0.6, adj=c(0,2))

#Stenoteles vs large crustaceans
stenoteles = categorical$Heteroneme.type %>% as.character()
categorical <- read.csv("Homolog_Categorical.csv")[,-2]
categorical$Species<-as.character(categorical$Species)
categorical$Species[which(categorical$Species == "Agalma okeni")] <- "Agalma okenii"
categorical$Species[which(categorical$Species == "Rhizophysa eysenhardti")] <- "Rhizophysa eysenhardtii"
categorical$Species[which(categorical$Species == "Nanomia bijuga")] <- "Nanomia sp"
names(stenoteles)=categorical$Species
stenoteles[stenoteles!="Stenotele"]<-0
stenoteles[stenoteles=="Stenotele"]<-1
shrimp = hypdiet
shrimp[shrimp!="Large crustacean" & shrimp!= "Mixed"]<-0
shrimp[shrimp=="Large crustacean" | shrimp== "Mixed"]<-1
stenoteles = stenoteles[which(names(stenoteles) %in% names(shrimp))]
stenoteles = stenoteles[match(names(shrimp), names(stenoteles))]
fitPagel(dprunedTree, stenoteles, shrimp) %>% .$P

#Diet heatmap next to regime tree
RTorder = regimetree$tip.label
diet[match(RTorder, rownames(diet)),] %>% as.matrix() %>% heatmap(Rowv=NA, Colv=NA, col=c("grey", "black"))


```

3.1 Table showing quantitative and categorical characters association effect size with each prey type in the diet.

Nematocyst morphology appears to be associated to prey type presence in diet. Phylogenetic regression with frequencies of prey types (in 8 species) revealed that decapod larvae consumption is associated to many traits, while fish larvae specialization is only associated to more rounded nematocyst shapes with stubbier shafts, and copepod specialization is mainly associated to fewer nematocyst and thinner tentacles. Transitions to fish and copepod specialization correlate with regime shifts in the rates for those characters (detected with BAMM).

```{r prey-character-assoc}
#Phylogenetic ANOVAS with prey type presence
pANOVAs_diet = as.data.frame(matrix(ncol=ncol(dprunedmatrix_logs[,-1]), nrow=ncol(diet)))
rownames(pANOVAs_diet) = names(diet)
colnames(pANOVAs_diet) = names(dprunedmatrix_logs[,-1])
for(prey in 1:ncol(diet)){
  CH_J=diet[,prey]
  names(CH_J) = rownames(diet)
  for(char in 1:ncol(dprunedmatrix_logs[,-1])){
    CH_I = dprunedmatrix_logs[,char+1]
    names(CH_I) = dprunedmatrix_logs$Species
    CH_I = CH_I[!is.na(CH_I)]
    CH_J = CH_J[which(names(CH_J)%in%names(CH_I))]
    treeIJ = drop.tip(dprunedTree, which(!(dprunedTree$tip.label %in% names(CH_I))))
    if(length(unique(CH_I))>1 & length(unique(CH_J))>1){
    #phylANOVA(treeIJ,x=CH_J,y=CH_I) %>% .$Pf -> pANOVAs_diet[prey,char]
       #phylANOVA(treeIJ,x=CH_J,y=CH_I) %>% .$Pf -> pANOVAs_diet[prey,char]
    gls(CH_I ~ CH_J, correlation =  corBrownian(phy = treeIJ), data = as.data.frame(cbind(CH_I,CH_J)), method = "ML") %>% summary() %>% .$tTable %>% as.data.frame() %>% .$p %>% .[2] -> pANOVAs_diet[prey,char]
  }
  }}
pANOVAs_diet = pANOVAs_diet[,-1]
pANOVAs_diet[pANOVAs_diet>0.05] <- NA
#write.csv(pANOVAs_diet, "pANOVAS_Diet.csv")

#PGLS with proportions in Diet
pGLSp_diet = as.data.frame(matrix(nrow=ncol(Pprunedmatrix_logs[,-1]), ncol=ncol(PP)))
pGLS_sign = pGLSp_diet
colnames(pGLSp_diet) = names(PP)
row.names(pGLSp_diet) = names(Pprunedmatrix_logs[,-1])
pGLS_sign = pGLSp_diet
for(i in 2:ncol(Pprunedmatrix_logs)){
  CH_I=as.numeric(Pprunedmatrix_logs[,i])
  names(CH_I) = Pprunedmatrix_logs$Species
  CH_I = CH_I[!is.na(CH_I)]
  for(j in 1:ncol(PP)){
    CH_J=as.numeric(PP[,j])
    names(CH_J) = rownames(PP)
    CH_J = CH_J[!is.na(CH_J)]
    CH_I = CH_I[which(names(CH_I) %in% names(CH_J))]
    CH_J = CH_J[which(names(CH_J) %in% names(CH_I))]
    SE_I = castSE_logs[which(castSE$Species %in% names(CH_I)),i]
    names(SE_I) = castSE_logs[which(castSE$Species %in% names(CH_I)),1]
    SE_I = SE_I[match(names(CH_I), names(SE_I))]
    pgls_tree = drop.tip(Pprunedtree, which(!(Pprunedtree$tip.label %in% names(CH_I))))
    pg_data = as.data.frame(cbind(CH_I,CH_J)) %>% .[which(!is.na(rowSums(.))),]
    pgls.SEy(CH_I~CH_J, data=pg_data, tree = pgls_tree, se = SE_I) -> TTABLE
    pgls.SEy(CH_I~sample(CH_J, length(CH_J)), data=pg_data, tree = pgls_tree, se = SE_I) -> TTABLE_null
    #TTABLE <- gls(CH_I ~ CH_J, correlation =  corBrownian(phy = pgls_tree), data = pg_data, method = "ML") %>% summary() %>% .$tTable %>% as.data.frame()
    LikRat <- 2*(TTABLE$logLik[1] - TTABLE_null$logLik[1])
    pchisq(LikRat, df=1, lower.tail = F) -> pGLSp_diet[i-1,j]
    if(pGLSp_diet[i-1,j]<0.05){
     print(paste(rownames(pGLSp_diet)[i-1],colnames(pGLSp_diet)[j],pGLSp_diet[(i-1),(j)],sep=" "))
     ValueIJ = TTABLE %>% .$coefficients %>% .[2]
     if(ValueIJ>0){pGLS_sign[i-1,j] = "+"}
      else pGLS_sign[i,j] = "-"
   }
  }
}
write.csv(pGLSp_diet, "PGLS_Pval_DietPP.csv")
pGLS_sign <- pGLS_sign[which(rowSums(is.na(pGLS_sign))!=ncol(pGLS_sign)),which(colSums(is.na(pGLS_sign))!=nrow(pGLS_sign))]
#write.csv(pGLS_sign, "PGLS_SIGN_DietPP.csv")

#PGLS with Purcell Selectivity
pGLSp_sel = as.data.frame(matrix(nrow=ncol(Sprunedmatrix_logs[,-1]), ncol=ncol(selectivity)))
pGLS__sel_sign = pGLSp_sel
colnames(pGLSp_sel) = names(selectivity)
row.names(pGLSp_sel) = names(Sprunedmatrix_logs[,-1])
pGLS_sel_sign = pGLSp_sel
for(i in 2:ncol(Sprunedmatrix_logs)){
  CH_I=as.numeric(Sprunedmatrix_logs[,i])
  names(CH_I) = Sprunedmatrix_logs$Species
  CH_I = CH_I[!is.na(CH_I)]
  for(j in 1:ncol(selectivity)){
    CH_J=as.numeric(selectivity[,j])
    names(CH_J) = rownames(selectivity)
    CH_J = CH_J[!is.na(CH_J)]
    CH_I = CH_I[which(names(CH_I) %in% names(CH_J))]
    CH_J = CH_J[which(names(CH_J) %in% names(CH_I))]
    SE_I = castSE_logs[which(castSE$Species %in% names(CH_I)),i]
    names(SE_I) = castSE_logs[which(castSE$Species %in% names(CH_I)),1]
    SE_I = SE_I[match(names(CH_I), names(SE_I))]
    pgls_tree = drop.tip(Sprunedtree, which(!(Sprunedtree$tip.label %in% names(CH_I))))
    pg_data = as.data.frame(cbind(CH_I,CH_J)) %>% .[which(!is.na(rowSums(.))),]
    if(length(unique(CH_J))>1){
          pgls.SEy(CH_I~CH_J, data=pg_data, tree = pgls_tree, se = SE_I) -> TTABLE
          pgls.SEy(CH_I~sample(CH_J, length(CH_J)), data=pg_data, tree = pgls_tree, se = SE_I) -> TTABLE_null
          LikRat <- 2*(TTABLE$logLik[1] - TTABLE_null$logLik[1])
          pchisq(LikRat, df=1, lower.tail = F) -> pGLSp_sel[i-1,j]
          if(pGLSp_sel[i-1,j]<0.05){
          print(paste(rownames(pGLSp_sel)[i-1],colnames(pGLSp_sel)[j],pGLSp_sel[(i-1),(j)],TTABLE$coefficients[2], sep=" "))
          ValueIJ = TTABLE %>% .$coefficients %>% .[2]
          if(ValueIJ>0){pGLS_sel_sign[i-1,j] = "+"}
          else pGLS_sel_sign[i,j] = "-"
         }
       }
    else TTABLE<-NA; TTABLE_null<-NA; LikRat<-NA; pGLSp_sel[i-1,j]<-NA
  }
}
write.csv(pGLSp_sel, "PGLS_Pval_Selectivity.csv")
pGLS_sel_sign <- pGLS_sel_sign[which(rowSums(is.na(pGLSp_sel))!=ncol(pGLS_sel_sign)),which(colSums(is.na(pGLS_sel_sign))!=nrow(pGLS_sel_sign))]
write.csv(pGLS_sel_sign, "PGLS_SIGN_Selectivity.csv")

#using PCs instead of characters
dprunedmatrix[,c(2:3,5:21)] -> dprunedraw
rownames(dprunedraw) = dprunedmatrix$Species
dprunedraw %>% .[which(!is.na(rowSums(.))),] %>% PCA() -> dprunedPCA
CH_I = dprunedPCA$ind$coord[,1]
for(prey in 1:ncol(diet)){
  CH_J=diet[,prey]
  names(CH_J) = rownames(diet)
  CH_J = CH_J[which(names(CH_J)%in%names(CH_I))]
  treeIJ = drop.tip(dprunedTree, which(!(dprunedTree$tip.label %in% names(CH_I))))
  if(length(unique(CH_I))>1 & length(unique(CH_J))>1){
    print(names(diet)[prey])
    #phylANOVA(treeIJ,x=CH_J,y=CH_I) %>% .$Pf -> pANOVAs_diet[prey,char]
    phylANOVA(treeIJ,x=CH_J,y=CH_I) %>% .$Pf %>% print()
  #gls(CH_I ~ CH_J, correlation =  corBrownian(phy = treeIJ), data = as.data.frame(cbind(CH_I,CH_J)), method = "ML") %>% summary() %>% .$tTable %>% as.data.frame() %>% .$p %>% .[2]  %>% print()
  }
  }

#LOGISTIC REGRESSION
logits = data.frame(matrix(ncol = 9, nrow = 0))
names(logits) = c("Prey type", "Character", "Ntaxa", "phyloglmAIC", "phyloglmP","phyloglm_b","glmAIC", "glmP", "glm_b")
logit_diet = diet[,-7]
logits[1,] = rep(1,9)
for(prey in 1:ncol(logit_diet)){
  for(char in 2:ncol(dprunedmatrix_logs)){
    CH_J=logit_diet[,prey]
    names(CH_J) = rownames(logit_diet)
    CH_I = dprunedmatrix_logs[,char]
    names(CH_I) = dprunedmatrix_logs$Species
    CH_I = CH_I[!is.na(CH_I)]
    CH_J = CH_J[which(names(CH_J)%in%names(CH_I))]
    treeIJ = drop.tip(dprunedTree, which(!(dprunedTree$tip.label %in% names(CH_J))))
    CH_I = CH_I[match(treeIJ$tip.label, names(CH_I))]
    CH_J = CH_J[match(treeIJ$tip.label, names(CH_J))]
    datIJ = data.frame(preytype = CH_J, character = CH_I)
      if(length(unique(CH_I))>1 & length(unique(CH_J))>1){
      logit = glm(preytype~character,data=datIJ, family="binomial")
      print(logit)
      phylogit = phyloglm(preytype~character,phy=treeIJ,data=datIJ,boot=10, btol=30)
      print(phylogit)
      rowIJ = c(names(logit_diet)[prey], names(dprunedmatrix_logs)[char], phylogit$n, phylogit$aic, coef(summary(phylogit))[2,6], coef(summary(phylogit))[2,1], logit$aic, coef(summary(logit))[2,4], coef(summary(logit))[2,1])
      } else{
      rowIJ = c(names(logit_diet)[prey], names(dprunedmatrix_logs)[char], NA, NA, NA, NA, NA, NA, NA)
      }
    print(rowIJ)
    logits = rbind(logits, rowIJ)
  }
}
logits = logits[-1,]
logits[,4:9] = sapply(logits[,4:9], as.numeric)
logits[,4:9] = sapply(logits[,4:9], function(x){round(x,3)})
write.csv(logits, "diet_morph_logits.csv", row.names = F)

#Soft-Hard logistic regression
logits = data.frame(matrix(ncol = 9, nrow = 0))
names(logits) = c("Prey type", "Character", "Ntaxa", "phyloglmAIC", "phyloglmP","phyloglm_b","glmAIC", "glmP", "glm_b")
logit_diet = soft_hard
logits[1,] = rep(1,9)
for(prey in 1:ncol(logit_diet)){
  for(char in 2:ncol(dprunedmatrix_logs)){
    CH_J=logit_diet[,prey]
    names(CH_J) = rownames(logit_diet)
    CH_I = dprunedmatrix_logs[,char]
    names(CH_I) = dprunedmatrix_logs$Species
    CH_I = CH_I[!is.na(CH_I)]
    CH_J = CH_J[which(names(CH_J)%in%names(CH_I))]
    treeIJ = drop.tip(ultram, which(!(ultram$tip.label %in% names(CH_J))))
    CH_I = CH_I[match(treeIJ$tip.label, names(CH_I))]
    CH_J = CH_J[match(treeIJ$tip.label, names(CH_J))]
    datIJ = data.frame(preytype = CH_J, character = CH_I)
    print(length(unique(CH_J)))
    print(cbind(CH_I, CH_J))
      if(length(unique(CH_J))>1){
      logit = glm(preytype~character,data=datIJ, family="binomial")
      #print(logit)
      phylogit = phyloglm(preytype~character,phy=treeIJ,data=datIJ,boot=10, btol=20)
      #print(phylogit)
      rowIJ = c(names(logit_diet)[prey], names(dprunedmatrix_logs)[char], phylogit$n, phylogit$aic, coef(summary(phylogit))[2,6], coef(summary(phylogit))[2,1], logit$aic, coef(summary(logit))[2,4], coef(summary(logit))[2,1])
      print(rowIJ)
      } else{
      rowIJ = c(names(logit_diet)[prey], names(dprunedmatrix_logs)[char], phylogit$n, NA, NA, NA, NA, NA, NA)
      }
    print(rowIJ)
    logits = rbind(logits, rowIJ)
  }
}
logits = logits[-1,]
logits[,4:9] = sapply(logits[,4:9], as.numeric)
logits[,4:9] = sapply(logits[,4:9], function(x){round(x,3)})
write.csv(logits, "logits_softhard.csv", row.names = F)

datcombo = dprunedmatrix_logs[,c(1,2,5,7,9)]
rownames(datcombo) = datcombo[,1]
datcombo = datcombo[,-1]
datcombo = datcombo[which(!is.na(rowSums(datcombo))),]
names(datcombo) = c("heteroneme_length","heteroneme_shaft_length","heteroneme_number", "haploneme_width")
cop = diet$`Copepod diet`
names(cop) = rownames(diet)
cop = cop[which(names(cop) %in% rownames(datcombo))]
coptree = drop.tip(dprunedTree, which(!(dprunedTree$tip.label %in% names(cop))))
datcombo = datcombo[match(coptree$tip.label, rownames(datcombo)),]
cop = cop[match(coptree$tip.label, names(cop))]
combo_phylogit = phyloglm(cop~heteroneme_length+heteroneme_shaft_length+heteroneme_number+haploneme_width,phy=coptree,data=datcombo,boot=10, btol=100)
coef(summary(combo_phylogit))

#Plot mirror trees QUANT
X = dprunedmatrix_logs$Haploneme.free.length..um.
names(X) = dprunedmatrix_logs$Species
X=X[!(is.na(X))]
Y = diet$`Decapod diet`
names(Y) = rownames(diet)

X = nematocyst_number
Y = soft_hard$Soft
Y=softORhard[,1]
names(Y) = rownames(softORhard)
Y[Y!="Soft"]<-0
Y[Y=="Soft"]<-1

Y = Y[which(names(Y) %in% names(X))]
X = X[which(names(X) %in% names(Y))]
treeXY = drop.tip(dprunedTree, which(!(dprunedTree$tip.label %in% names(X))))
layout(matrix(1:3,1,3),widths=c(0.44,0.12,0.44))
par(cex=0.5)
#pdf("deliverables/Hvol_copepod.pdf",width=10,height=6)
OX = contMap(treeXY,X,sig=1,legend=1, plot = F, outline = F)
OX$cols[1:length(OX$cols)] = colorRampPalette(c("blue","red"), space="Lab")(length(OX$cols))
plot(OX,ftype="off")
ylim<-c(1-0.12*(length(treeXY$tip.label)-1),length(treeXY$tip.label))
plot.new(); plot.window(xlim=c(-0.1,0.1),ylim=ylim)
text(rep(0,length(treeXY$tip.label)), 1:length(treeXY$tip.label),treeXY$tip.label)
OY = contMap(treeXY,Y, sig=1,legend=1, plot = F,  outline = F)
OY$cols[1:length(OY$cols)] = colorRampPalette(c("orange","green"), space="Lab")(length(OY$cols))
plot(OY, direction="leftwards", ftype = "off")

X = Pprunedmatrix_logs$Heteroneme.volume..um3.
names(X) = Pprunedmatrix_logs$Species
Y = PP$`Relative decapod consumption`
names(Y) = rownames(PP)
layout(matrix(1:3,1,3),widths=c(0.44,0.12,0.44))
par(cex=0.5)
#pdf("deliverables/Hvol_copepod.pdf",width=10,height=6)
OX = contMap(Pprunedtree,X,sig=1,legend=1, plot = F, outline = F)
OX$cols[1:length(OX$cols)] = colorRampPalette(c("blue","red"), space="Lab")(length(OX$cols))
plot(OX,ftype="off")
ylim<-c(1-0.12*(length(Pprunedtree$tip.label)-1),length(Pprunedtree$tip.label))
plot.new(); plot.window(xlim=c(-0.1,0.1),ylim=ylim)
text(rep(0,length(Pprunedtree$tip.label)), 1:length(Pprunedtree$tip.label),Pprunedtree$tip.label)
OY = contMap(Pprunedtree,Y, sig=1,legend=1, plot = F,  outline = F)
OY$cols[1:length(OY$cols)] = colorRampPalette(c("orange","green"), space="Lab")(length(OY$cols))
plot(OY, direction="leftwards", ftype = "off")


```

3.2 Table showing the dAICc of OU model fitting versus white_noise and BM using reconstructed diets as regimes in a 16 spp tree. Evaluate model adequacy of OU fits.

When I mapped trait evolution onto a diet SIMMAP regime tree, OU models using the reconstructed states as regimes fitted significantly better (dAICc>2) than BM (null models) for cnidoband coiledness, heteroneme shaft shape, haploneme length, haploneme row number, desmoneme length, and desmoneme width.

```{r OUwie}
OUwie_matrix = as.data.frame(matrix(ncol=5, nrow=nrow(dprunedmatrix_logs)))
names(OUwie_matrix) = c("Character", "Ntips", "dAICc_BM", "dAICc_OU1", "dAICc_OUm")
library(magrittr)
for(c in 2:ncol(dprunedmatrix_logs)){
  Cdata = data.frame(dprunedmatrix$Species,hypdiet,dprunedmatrix_logs[,c])
  names(Cdata) = c("species", "regime", "trait")
  Cdata$trait[which(Cdata$trait == "NaN")] <- NA
  Cdata = Cdata[!is.na(Cdata$trait),]
  Cdata$trait = as.numeric(Cdata$trait)
  Cdata$species = as.character(Cdata$species)
  Cdata$regime = as.character(Cdata$regime)
  Ctree = drop.tip(regimetree,which(!(regimetree$tip.label %in% Cdata$species)))
  BM <- OUwie(Ctree, Cdata, model="BM1")
  OU1 <- OUwie(Ctree, Cdata, model="OU1")
  OUm <- OUwie(Ctree, Cdata, model="OUMV")
  OUwie_matrix[c-1,1] = names(dprunedmatrix_logs)[c]
  OUwie_matrix[c-1,2] = nrow(Cdata)
  OUwie_matrix[c-1,3] = BM$AICc - min(c(BM$AICc, OU1$AICc, OUm$AICc))
  OUwie_matrix[c-1,4] = OU1$AICc - min(c(BM$AICc, OU1$AICc, OUm$AICc))
  OUwie_matrix[c-1,5] = OUm$AICc - min(c(BM$AICc, OU1$AICc, OUm$AICc))
}
OUwie_matrix[,3:5] <- apply(OUwie_matrix[,3:5], 2, round3)
write.csv(OUwie_matrix, "OU_diet_test.csv")

#SOFT-HARD OUWIE

SH_matrix = as.data.frame(matrix(ncol=5, nrow=nrow(dprunedmatrix_logs)))
names(SH_matrix) = c("Character", "Ntips", "dAICc_BM", "dAICc_OU1", "dAICc_OUm")
for(c in 2:ncol(dprunedmatrix_logs)){
  Cdata = data.frame(dprunedmatrix$Species,hypSH,dprunedmatrix_logs[,c])
  names(Cdata) = c("species", "regime", "trait")
  Cdata$trait[which(Cdata$trait == "NaN")] <- NA
  Cdata = Cdata[!is.na(Cdata$trait),]
  Cdata$trait = as.numeric(Cdata$trait)
  Cdata$species = as.character(Cdata$species)
  Cdata$regime = as.character(Cdata$regime)
  Ctree = drop.tip(SHtree,which(!(SHtree$tip.label %in% Cdata$species)))
  BM <- OUwie(Ctree, Cdata, model="BM1")
  OU1 <- OUwie(Ctree, Cdata, model="OU1")
  OUm <- OUwie(Ctree, Cdata, model="OUMV")
  SH_matrix[c-1,1] = names(dprunedmatrix_logs)[c]
  SH_matrix[c-1,2] = nrow(Cdata)
  SH_matrix[c-1,3] = BM$AICc - min(c(BM$AICc, OU1$AICc, OUm$AICc))
  SH_matrix[c-1,4] = OU1$AICc - min(c(BM$AICc, OU1$AICc, OUm$AICc))
  SH_matrix[c-1,5] = OUm$AICc - min(c(BM$AICc, OU1$AICc, OUm$AICc))
}
SH_matrix[,3:5] <- apply(SH_matrix[,3:5], 2, round3)
write.csv(SH_matrix, "OU_SH_test.csv")

#Using raw morphospace
rawcoords = Pca_raw$ind$coord[,1:2]
rawcoords = rawcoords[which(rownames(rawcoords) %in% names(hypdiet)),]
OUwie_matrix = as.data.frame(matrix(ncol=5, nrow=2))
names(OUwie_matrix) = c("Character", "Ntips", "dAICc_BM", "dAICc_OU1", "dAICc_OUMV")
library(magrittr)
for(c in 1:ncol(rawcoords)){
  Cdata = data.frame(rownames(rawcoords),hypdiet[which(names(hypdiet) %in% rownames(rawcoords))],rawcoords[,c])
  names(Cdata) = c("species", "regime", "trait")
  Cdata$trait[which(Cdata$trait == "NaN")] <- NA
  Cdata = Cdata[!is.na(Cdata$trait),]
  Cdata$trait = as.numeric(Cdata$trait)
  Cdata$species = as.character(Cdata$species)
  Cdata$regime = as.character(Cdata$regime)
  Ctree = drop.tip(regimetree,which(!(regimetree$tip.label %in% Cdata$species)))
  BM <- OUwie(Ctree, Cdata, model="BM1")
  OU1 <- OUwie(Ctree, Cdata, model="OU1")
  OUm <- OUwie(Ctree, Cdata, model="OUMV")
  OUwie_matrix[c,1] = c("PC1","PC2")[c]
  OUwie_matrix[c,2] = nrow(Cdata)
  OUwie_matrix[c,3] = BM$AICc - min(c(BM$AICc, OU1$AICc, OUm$AICc))
  OUwie_matrix[c,4] = OU1$AICc - min(c(BM$AICc, OU1$AICc, OUm$AICc))
  OUwie_matrix[c,5] = OUm$AICc - min(c(BM$AICc, OU1$AICc, OUm$AICc))
}
OUwie_matrix[,3:5] <- apply(OUwie_matrix[,3:5], 2, round3)
write.csv(OUwie_matrix, "OU_raw_test.csv")

#Using compound mosphospace
# compcoords = Pca_compound$ind$coord[,1:2]
# compcoords = compcoords[which(rownames(compcoords) %in% names(hypdiet)),]
# OUwie_matrix = as.data.frame(matrix(ncol=4, nrow=2))
# names(OUwie_matrix) = c("Character", "Ntips", "dAICc_BM", "dAICc_OU1", "dAICc_OUMV")
# library(magrittr)
# for(c in 1:ncol(compcoords)){
#   Cdata = data.frame(rownames(compcoords),hypdiet[which(names(hypdiet) %in% rownames(compcoords))],compcoords[,c])
#   names(Cdata) = c("species", "regime", "trait")
#   Cdata$trait[which(Cdata$trait == "NaN")] <- NA
#   Cdata = Cdata[!is.na(Cdata$trait),]
#   Cdata$trait = as.numeric(Cdata$trait)
#   Cdata$species = as.character(Cdata$species)
#   Cdata$regime = as.character(Cdata$regime)
#   Ctree = drop.tip(regimetree,which(!(regimetree$tip.label %in% Cdata$species)))
#   BM <- OUwie(Ctree, Cdata, model="BM1")
#   OU1 <- OUwie(Ctree, Cdata, model="OU1")
#   OUm <- OUwie(Ctree, Cdata, model="OUMV")
#   OUwie_matrix[c,1] = c("PC1","PC2")[c]
#   OUwie_matrix[c,2] = nrow(Cdata)
#   OUwie_matrix[c,3] = BM$AICc - min(c(BM$AICc, OU1$AICc, OUm$AICc))
#   OUwie_matrix[c,4] = OU1$AICc - min(c(BM$AICc, OU1$AICc, OUm$AICc))
#   OUwie_matrix[c,5] = OUm$AICc - min(c(BM$AICc, OU1$AICc, OUm$AICc))
# }
# OUwie_matrix[,3:5] <- apply(OUwie_matrix[,3:5], 2, round3)
# write.csv(OUwie_matrix, "OU_compound_test.csv")
```

```{r, BAMM_output, echo=F}
# load BAMM main output
edata <- getEventData(BAMMtree, eventdata = "BAMM/Cnidoband_free_length/event_data.txt", burnin=0.2, type="trait")
summary(edata)

regimes = edata$tipStates[[3]] %>% .[which(str_replace_all(BAMMtree$tip.label,"_", " ") %in% dprunedTree$tip.label)]
names(regimes) = edata$tip.label[which(str_replace_all(BAMMtree$tip.label,"_", " ") %in% dprunedTree$tip.label)] %>% str_replace_all("_", " ")
for(prey in 1:ncol(diet)){
  print(names(diet)[prey])
  food=diet[,prey]
  names(food) = rownames(diet)
  food = food[which(names(food)%in%names(regimes))]
  food = food[match(names(regimes), names(food))]
  if(length(unique(food))>1){
    pgls.SEy(food~regimes,data=data.frame(food,regimes), tree=dprunedTree)
  }}
```

3.3 Interpret qualitatively the kinematic implications (high speed video) of the different regions of the morphospace.

``` {r kine}
kine = read.csv("Kinematics.tsv", sep='\t', header=T) #%>% .[which(apply(., 1, function(x) sum(is.na(x)))<ncol(.)-2),-2]
kineWNA = kine[which(kine$Species %in% ultram$tip.label),]
rownames(kineWNA)=kineWNA$Specimen
rownames(kine)=kine$Specimen
#kineWNA = kineWNA[,-1]
#kine=kine[,-1]
kinetree = drop.tip(ultram, which(!(ultram$tip.label %in% kine$Species)))
kinetree$edge.length = 200*kinetree$edge.length
#kine_clean = kineWNA[,which(colSums(kineWNA)>1)]
#names(kine) = c("ADS", "MDS", "HeDS","HeMDS", "HSDS", "HFL", "HaDS")
kine_byspp = aggregate(. ~ kine$Species, data = kine[,c(-1,-2)], mean.na, na.action = na.pass)
names(kine_byspp)[1] <- "Species"
kinemorph <- castmeans[which(castmeans$Species %in% kine_byspp$Species),] %>% cbind(kine_byspp[which(kine_byspp$Species %in% castmeans$Species),])
plot(kinemorph$Cnidoband.free.length..um., kinemorph$Average.CB.discharge.speed..mm.s.)
calys = kinemorph$Species[c(5,9,12,15,16,17,18)]
euphys = kinemorph$Species[which(!(kinemorph$Species %in% calys))]
relspeed = data.frame(kinemorph$Species, c(kinemorph$Average.CB.discharge.speed..mm.s./kinemorph$Cnidoband.free.length..um.))
names(relspeed) = c("Species", "Speed/Length")
relspeed <- relspeed[which(!(is.na(relspeed$`Speed/Length`))),]
t.test(relspeed[which(relspeed$Species %in% calys),2], relspeed[which(relspeed$Species %in% euphys),2])
t.test(kine$Average.CB.discharge.speed..mm.s.[which(kine$Species %in% calys)], kine$Average.CB.discharge.speed..mm.s.[which(kine$Species %in% euphys)])
t.test(castnumbers$Cnidoband.free.length..um.[which(castnumbers$Species %in% calys)], castnumbers$Cnidoband.free.length..um.[which(castnumbers$Species %in% euphys)])
lm(kinemorph$Average.CB.discharge.speed..mm.s.~ kinemorph$Cnidoband.free.length..um.) %>% summary()
lm(kinemorph$Heteroneme.discharge.speed.MAX..mm.s.~ kinemorph$Heteroneme.volume..um3.) %>% summary()
t.test(kine$Heteroneme.discharge.speed.AVG..mm.s.[which(kine$Species %in% calys)], kine$Heteroneme.discharge.speed.AVG..mm.s.[which(kine$Species %in% euphys)])
t.test(kine$Haploneme.discharge.speed.AVG..mm.s.[which(kine$Species %in% calys)], kine$Haploneme.discharge.speed.AVG..mm.s.[which(kine$Species %in% euphys)])
t.test(kine$Haploneme.discharge.speed.AVG..mm.s., kine$Heteroneme.discharge.speed.AVG..mm.s.)
cor(kinemorph[,c(-1,-32)], use="pairwise.complete.obs") %>% .[c(1:30),c(31:41)] %>% corrplot(diag=F, tl.cex = 0.4, tl.col="black")

```

High-speed video of cnidoband and nematocyst discharge revealed the roles of the different tentillum substructures in the mechanics of discharge. Moreover, it shows important differences in the discharge dynamics of species with different tentillum morphologies.

Videos have shown the double role of the elastic strands in initiating and controlling cnidoband discharge. A few milliseconds before cnidoband discharge, the distal attachment of the cnidoband (at the base of the terminal filament) appears to unwind to the point of a tension-release threshold. This observation indicates there might be spring mechanism driving the discharge process. 

Euphysonect tentilla discharge considerably faster than Calycophoran tentilla. Larger heteronemes discharge faster than small ones, giving Euphysonects a faster heteroneme discharge speed than most Calycophorans. On the contrary, Calycophoran haploneme tubules fire faster than those of Euphysonects.

The more extreme the coiledness index, the more unpredictable the trajectory of the cnidoband during discharge.

Story: low dimensionality, cost-reward-driven, dynamic specialization.

## 4. Discussion

A particularly interesting case is that of *Cordagalma ordinatum*, a specialized copepod eater [@purcell1981dietary], which is sister to the generalist genus *Forskalia*. *Cordagalma*’s tentilla strongly resemble the larval (protozooid exclusive) tentilla of *Forskalia* spp. This could indicate a case of paedomorphosis as a pathway to predatory specialization.

The calycophoran morphospace is quite distinct from that of other siphonophores, revealing a potential reaction line in the 2 PCs (Figure XX). A non-calycophoran (*Frillagalma vityazi*), has secondarily occupied this morphospace, which could indicate a case of convergence.

The new phylogeny delivered by this chapter will become a fundamental resource for subsequent studies of siphonophore evolution.  In addition, a broad and detailed characterization of tentilla morphology and its phylogenetic distribution provide complementary tools for taxonomy, identification, and morphological delimitation. 


## 5. Conclusions

The genera *Erenna* and *Stephanomia* form a monophyletic clade characterized by bearing extremely large tentilla. 



## Acknowledgements

This work was funded by the Society of Systematic Biologists Graduate Student Award, the NSF Waterman Award,  the Yale Institute of Biospheric Studies Doctoral Pilot Grant, and the NSF Collaborative Research project SiphWeb. ADS was supported by a Fulbright Spain scholarship. We thank Dr. Philip R. Pugh for his assistance in the identification of specimens. We also wish to thank the crew of the R/V Western Flyer.

## References
