---
bibliography: manuscript.bib
csl: systematic-biology.csl
site: "bookdown::bookdown_site"
output:
  bookdown::pdf_document2:
    toc: FALSE
---

```{r setup, include=FALSE}
	# Load packages
	## General
library(knitr)
library(tidyverse)
library(stringr)
library(reshape2)
	## Biological
library(OUwie)
library(Rphylip)
library(arbutus)
library(vegan)
library(ape)
library(phangorn)
library(phytools)
library(picante)
library(geiger)
library(phylobase)
library(fields)
library(phylosignal)
library(geomorph)
library(phylopath)
	## Graphics
library(FactoMineR)
library(factoextra)
library(corrplot)
library(BAMMtools)

	# Configure knitr, see http://yihui.name/knitr/options
	opts_knit$set(
	  progress=TRUE,
	  verbose=TRUE)
	opts_chunk$set(
	#  include=FALSE,
	  cache=TRUE,
	  echo=FALSE,
	  message=FALSE
	 )
	# Set paths to input data
	setwd("~/tentilla_morph")
	
	#Load raw data
  read.csv("byslide.csv") -> numbers
  categorical <- read.csv("Homolog_Categorical.csv")[,-2]
  rownames(categorical) = categorical$Species
  
  #Correct species spellings
  numbers$Species[which(numbers$Species == "Agalma okeni")] <- "Agalma okenii"
  numbers$Species[which(numbers$Species == "Forskalia edwardsi")] <- "Forskalia edwardsii"
  numbers$Species[which(numbers$Species == "Rhizophysa eysenhardti")] <- "Rhizophysa eysenhardtii"

  #Merge Nanomias
  numbers$Species[which(numbers$Species == "Nanomia cara")] <- "Nanomia sp"
  numbers$Species[which(numbers$Species == "Nanomia bijuga")] <- "Nanomia sp"
  
  #Polish fields
  castnumbers = numbers
  castnumbers[castnumbers=="needDIC"] <- NA
  castnumbers[castnumbers=="needConfocal"] <- NA
  castnumbers[castnumbers=="needMature"] <- NA
  castnumbers[castnumbers=="needReslide"] <- NA
  castnumbers[castnumbers==-1] <- NA
  castnumbers[,c(-1,-2,-3)] <- sapply(castnumbers[,c(-1,-2,-3)],as.character)
  castnumbers[,c(-1,-2,-3)] <- sapply(castnumbers[,c(-1,-2,-3)],as.numeric)
  
  #Define functions to deal with NAs and decimals
  mean.na <- function(a){mean(a, na.rm = TRUE)}
  var.na <- function(a){var(a, na.rm = TRUE)}
  round3 <- function(a){round(a, 3)}
  
  #Compute morphometric ratios
  coiledness = castnumbers$Cnidoband.free.length..um./castnumbers$Cnidoband.length..um.
  heteroneme_elongation = castnumbers$Heteroneme.free.length..um./castnumbers$Heteroneme.width..um.
  haploneme_elongation = castnumbers$Haploneme.free.length..um./castnumbers$Haploneme.width..um.
  desmoneme_elongation = castnumbers$Desmoneme.length..um./castnumbers$Desmoneme.width..um.
  rhopaloneme_elongation = castnumbers$Rhopaloneme.length..um./castnumbers$Rhopaloneme.width..um.
  heteroneme_shaft_extension = castnumbers$Heteroneme.free.length..um./castnumbers$Heteroneme.shaft.free.length..um.
  Heteroneme_to_CB = castnumbers$Heteroneme.free.length..um./(castnumbers$Cnidoband.free.length..um.+0.001)
  total_heteroneme_volume = castnumbers$Heteroneme.volume..um3.*castnumbers$Heteroneme.number
  total_haploneme_volume = (castnumbers$Cnidoband.free.length..um./castnumbers$Haploneme.width..um.)*((4*pi/3)*0.5*castnumbers$Haploneme.free.length..um.*((0.5*castnumbers$Haploneme.width..um.)^2))
  cnidomic_index = log(total_heteroneme_volume + total_haploneme_volume)
  cnidomic_index[which(is.na(cnidomic_index))] <- log(total_haploneme_volume[which(is.na(cnidomic_index))])
  cnidomic_index[which(is.na(cnidomic_index))] <- log(castnumbers[which(is.na(cnidomic_index)), "Heteroneme.volume..um3."])
  cnidomic_index[cnidomic_index==-Inf]<-NA
    morphometrics = data.frame(castnumbers$slide_id, castnumbers$Species,coiledness, heteroneme_elongation, haploneme_elongation, desmoneme_elongation, rhopaloneme_elongation,heteroneme_shaft_extension, Heteroneme_to_CB, total_heteroneme_volume, total_haploneme_volume, cnidomic_index)
  names(morphometrics)[1:2] = c("slide_id"," Species")
  castnumbers = data.frame(castnumbers,morphometrics[,c(-1,-2)])
  
  #logtransform variables which are not normal
  castlogs = castnumbers
  non_normal = apply(castnumbers[,c(-1,-2,-3)], 2, shapiro.test) %>% lapply(function(x){x$p.value}) %>% unlist() 
  non_normal = which(as.vector(non_normal) < 0.05)+3
  castlogs[,non_normal] <- sapply(castnumbers[,non_normal], log)
  castlogs[castlogs==-Inf]<-NA
  
  #Means, varinces, standard errors
  castmeans <- aggregate(. ~  Species, data = castnumbers[,c(-1,-3)], mean.na, na.action = na.pass)
  castmean_logs <- aggregate(. ~  Species, data = castlogs[,c(-1,-3)], mean.na, na.action = na.pass)
  castvariances <- aggregate(. ~  Species, data = castnumbers[,c(-1,-3)], FUN = var.na, na.action = na.pass) #[,-2]
  castvariance_logs <- aggregate(. ~  Species, data = castlogs[,c(-1,-3)], FUN = var.na, na.action = na.pass)
  castvariances[is.na(castvariances)] <- 0
  castvariance_logs[is.na(castvariance_logs)] <- 0
  castN <- aggregate(. ~  Species, data = castnumbers[,c(-1,-3)], length, na.action = na.pass) 
  castN = data.frame(castN$Species, rowMeans(castN[,-1])) #[,-2]
  names(castN) = c("Species", "N_specimens")
  castSE <- cbind(castvariances$Species, sqrt(castvariances[,-1])/sqrt(castN$N_specimens))
  castSE_logs <- cbind(castvariance_logs$Species, sqrt(castvariance_logs[,-1])/sqrt(castN[,-1]))
  names(castSE)[1] <- "Species"
  names(castSE_logs)[1] <- "Species"
```

# The evolution of siphonophore tentilla reveals association with diet {-}

Alejandro Damian-Serrano^1^,^‡, Steven H.D. Haddock^2^, Casey W. Dunn^1^

^1^ Department of Ecology and Evolutionary Biology, Yale University, New Haven, CT 06520, USA

^2^ Monterey Bay Aquarium Research Institute, Moss Landing, CA 95039, USA

\‡ Corresponding author, alejandro.damianserrano@yale.edu

## Abstract {-}

Siphonophores have the most complex nematocyst batteries of all Cnidaria. These structures are held on the tentacles’ side branches called tentilla. Tentilla serve as the principal organs for prey capture, making siphonophores an ideal system for the study of trophic specialization from an evolutionary approach. Modern comparative methods have been applied to study the evolution of siphonophore zooid types, but not yet to the unique morphological diversity of siphonophore tentilla. The primary objectives of this work are to describe the morphology and morphometrics of siphonophore tentilla and nematocysts, and identify patterns in the evolutionary history of siphonophore cnidoband and nematocyst morphologies. A phylogeny with XX species was reconstructed using 18S and 16S gene markers, constraining the topology with a transcriptome-based backbone. Morphological characters were measured from DIC and confocal microscopy images of fixed tentacle specimens. Diet data was extracted from published sources. The functional implications of the different morphologies during prey capture were recorded using high speed video on live specimens under a stereoscopic microscope. Evolutionary transitions in siphonophore tentilla present a very low dimensionality with a single principal component. This main axis of variation aligns with total nematocyst volume per tentillum. Most nematocyst complement (cnidome) traits appear to have evolved under simple Brownian Motion (BM) and Early Burst (EB) processes, while tentillum shape and size evolution is better represented by Ohrnstein-Uhlenbeck (OU) models. Many tentillum and cnidome traits show stronger supports towards OU models when diet is reconstructed on the tree as selective regimes. Using phylogenetic GLS we identified traits with correlated evolutionary histories, some of which are functionally coupled during prey capture. Size and abundance of nematocysts were phylogenetic correlated with prey type ratios in the diet. These patterns could represent macroevolutionary adaptive responses to prey availability leading to predatory specialization. Understanding the evolution of the prey capture apparatus of siphonophores can help us test hypotheses about the evolution of their predatory habits.

## 1. Introduction {-}

Siphonophores bear the most complex nematocyst batteries of all cnidarians, with up to 4 types of regionally differentiated nematocysts and a spring-release mechanism for fast discharge of the structure onto the prey. Not all siphonophores bear tentilla on their tentacles, exceptions include Apolemia spp. and Bathyphysa conifera. While Physalia physalis has been considered to have simple tentacles, it is likely that their button-like structures are homologous to reduced tentilla (Munro et al. 2018).
Each gastrozooid bears a single tentacle. Each tentacle serially buds tentilla from the basal region (basigaster), which develop as they are displaced further with tentacle growth. During development, tentilla grow and change shape into their final configuration while mature nematocysts formed in the basigaster migrate through the tentacle epidermis into the tentillum. Nematocysts arriving into the developing tentillum then rearrange into their final position (Skaer 1991). Tentilla are a single-use ensnaring weapon which is ingested and digested together with the prey it attached to.
The cnidoband and terminal filament bear all the active nematocysts. Cnidobands range in size from 40 microns to 8 cm, they can be coiled or straight, free hanging or enclosed in an involucrum (Mapstone 2014).

## 2. Methods {-}

### 3.1 Phylogeny{-}

Markers accessions

ML phylogeny was reconstructed from 16S and 18S ribosomal rRNA genes using iqtree(). 1000 bootstraps. 
A minimal set of nodes were constrained to be consistent with the (Munro etal 2018) transcriptome phylogeny strict consensus tree.

### 3.2 Microscopy{-}

All specimens are accessioned in the Yale Peabody Museum Invertebrate Zoology Collection. Accession numbers and collection data for the specimens are available in Supplementary Table XXX. All specimens were preserved in ~4% buffered formalin in seawater.

A total of 39 siphonophore species were selected based on availability and phylogenetic representativity criteria to capture intraspecific variation. Three to five specimens from each selected species were measured in order to account for intraspecific variation.

Tentacles from the studied specimens were dissected, dehydrated in a series of ethanol dilutions (25% in PBS, 50% in PBS, 75% in water, 100%), cleared in methyl salicylate or d-limonene, and mounted in plastic slides (Canada balsam, Cytoseal, or Permount). Slides were imaged using laser scanning confocal microscopy and differential interference contrast (DIC) microscopy. Images were measured using Fiji-ImageJ.

The characters measured for this study are described in Supplementary Table SXX. Homology assumptions for nematocyst supertypes (heteroneme, haploneme, rhopaloneme, and desmoneme) and tentillum structures (involucrum, elastic strand, pedicle, cnidoband) were informed by positional, developmental, and morphological criteria.

Diet data from Purcell 1981, Purcell 1984.

Microscopy ...

### 3.3 Phylogenetic Comparative Methods{-}

All phylogenetic statistical analyses were carried out in the programming environment R (cite). Phylogenetic signal in each of the measured characters was calculated using Blomberg’s K (Blomberg 2003). 

fitContinuous (geiger), BM, EB, OU.
Adams geomorph
phytools ppca, pgls, phyl.anova

### 3.4 High-Speed Video

High speed footage (1000-3000 fps) of tentillum and nematocyst discharge was recorded on live siphonophore specimens using a Phantom Miro 320S camera mounted on a stereoscopic microscope. Specimens were collected by SCUBA divers and the remotely operated underwater vehicle Doc Ricketts during expeditions onboard the R/V Western Flyer. Tentillum and nematocyst discharge were elicited mechanically using a fine metallic pin. Video footage was analyzed using Phantom PCC software.

## 3. Results {-}

0 -- PHYLOGENY
0.0 ML ribosomal marker phylogeny constrained by transcriptome tree with BS values at the nodes.
1 -- DESCRIPTIVE MORPHOLOGY AND EVOLUTIONARY HISTORY

```{r load_tree, include=F}
#Load tree
#consensus = ape::read.tree("concatenate.fasta.contree")
#consensus = read.nexus("gene_map_ct.tre")
consensus = read.nexus("TimeTree_CT_perfect.tre") %>% drop.tip(56:61)
#consensus = reroot(consensus,103)
#consensus = reroot(consensus,97)
#consensus = drop.tip(consensus, c(28,29,30,59:61))
#consensus = drop.tip(consensus, c(56:61))
consensus$tip.label = str_replace_all(consensus$tip.label,"_"," ")

#Prune quant matrix to tree species
matrix = castnumbers[which(!is.na(castnumbers$Species)),]
matrix_logs = castlogs[which(!is.na(castlogs$Species)),]
sharedspp = matrix$Species[which(matrix$Species %in% consensus$tip.label)]
sharedmatrix = matrix[which(matrix$Species %in% sharedspp),]
sharedlogs = matrix_logs[which(matrix$Species %in% sharedspp),]
sharedmeans = castmeans[which(castmeans$Species %in% sharedspp),]
sharedmean_logs = castmean_logs[which(castmean_logs$Species %in% sharedspp),]
sharedvars = castvariances[which(castvariances$Species %in% sharedspp),]
sharedvar_logs = castvariance_logs[which(castvariance_logs$Species %in% sharedspp),]
#sharedmeans = solidSPPmeans[which(solidSPPmeans$Species %in% sharedspp),]
#sharedvars = solidSPPvars[which(solidSPPvars$Species %in% sharedspp),]

#Prune categorical matrix to tree species
cat_rowNAs = apply(categorical[,-1], 1, function(x) sum(is.na(x)))
catmatrix = categorical[which(cat_rowNAs<1),] %>% .[,-1]
sharedspp_cat = rownames(catmatrix)[which(rownames(catmatrix) %in% consensus$tip.label)]
sharedcategorical = catmatrix[which(rownames(catmatrix) %in% sharedspp_cat),]

#Prune tree to quant matrix species
nodatatipnames = consensus$tip.label[which(!(consensus$tip.label %in% sharedmatrix$Species))]
nodatatips = c(1:length(consensus$tip.label))[which(consensus$tip.label %in% nodatatipnames)]
prunedtree = drop.tip(consensus, nodatatips)
prunedtree$tip.label
plot(prunedtree)

#Switch nanomia_bijuga for sp
prunedtree$tip.label[which(prunedtree$tip.label == "Nanomia bijuga")] <- "Nanomia sp"

#ultram = chronos(prunedtree)
ultram = prunedtree
plot(ultram)

##Make the pseudoindividuals tree
# newtree = ultram
# sharedmatrix_plied = sharedmatrix
# sharedmatrix_plied$slide_id = paste(sharedmatrix$slide_id, sharedmatrix$Species, sep = "_")
# for (i in 1:nrow(sharedmatrix_plied)) {
#   pos = which(newtree$tip.label == sharedmatrix_plied$Species[i])
#   print(pos)
#   newtree = bind.tip(newtree, sharedmatrix_plied$slide_id[i], where = pos, edge.length = 0.1)
#   print(newtree$tip.label)
#   newtree$tip.label = str_replace_all(newtree$tip.label,'_',' ')
# }
# inditree = drop.tip(newtree, which(!grepl(".[0-9].*", newtree$tip.label)))
# zerotipTree = inditree
# inditree$edge.length[inditree$edge.length==0] <- 0.0000000001
# shavedtree = inditree
# #inditree = chronos(inditree)
# plot(inditree)
# sharedmatrix_plied$slide_id = str_replace_all(sharedmatrix_plied$slide_id,'_',' ')
# sharedmatrix = sharedmatrix_plied[match(sharedmatrix_plied$slide_id, inditree$tip.label),]
# rownames(sharedmatrix) <- 1:nrow(sharedmatrix)

#Prune tree to categorical matrix species
nodatatipnames_cat = consensus$tip.label[which(!(consensus$tip.label %in% sharedspp_cat))]
nodatatips_cat = c(1:length(consensus$tip.label))[which(consensus$tip.label %in% nodatatipnames_cat)]
cat_tree = drop.tip(consensus, nodatatips_cat)
cat_tree$tip.label
plot(cat_tree)
#ultram_cat = chronos(cat_tree)
ultram_cat = cat_tree
plot(ultram_cat)
sharedcategorical = sharedcategorical[match(ultram_cat$tip.label, rownames(sharedcategorical)),]
cprunedmatrix = sharedcategorical[which(rownames(sharedcategorical)%in%rownames(sharedmatrix)),] %>% .[which(sapply(.,function(x) length(unique(x)))>1)]
sharedbinary = sharedcategorical
sharedbinary$Haploneme.type = as.character(sharedbinary$Haploneme.type)
sharedbinary[sharedbinary=="Isorhizas"] = 0
sharedbinary[sharedbinary=="Anisorhizas"] = 1
sharedbinary$Haploneme.type = as.numeric(sharedbinary$Haploneme.type)
sharedbinary$Heteroneme.type = as.character(sharedbinary$Heteroneme.type)
sharedbinary[sharedbinary=="Stenotele"] = 0
sharedbinary[sharedbinary=="Microbasic mastigophore"] = 1
sharedbinary[sharedbinary=="Eurytele"] = NA
sharedbinary$Heteroneme.type = as.numeric(sharedbinary$Heteroneme.type)

#purely numerics
Q_sharedmatrix = sharedmatrix[,c(-1,-2,-3)]
rownames(sharedmeans) = sharedmeans$Species
Q_sharedmeans = sharedmeans[,-1]
rownames(sharedvars) = sharedvars$Species
Q_sharedvars = sharedvars[,-1]
Q_sharedmean_logs = sharedmean_logs[,-1]
rownames(Q_sharedmean_logs) = sharedmean_logs$Species

```

Novel phylogenetic relationships:
-Erenna spp closely related to Stephanomia

1.0 Table showing for each species the mean, number of individuals measured, and standard error of every character, ordered by cnidomic index / tentillum size, and/or colored by clade.

```{r export_table_morph, include=FALSE}
morphdata = cbind(castN, castmeans[,-1], castSE[,-1])
morphdata = morphdata[,c(1:3,33,4,34,5,35,6,36,7,37,8,38,9,39,10,40,11,41,12,42,13,43,14,44,15,45,16,46,17,47,18,48,19,49,20,50,21,51,22,52,23,53,24,54,25,55,26,56,27,57,28,58,29,59,30,60,31,61,32,62)]
names(morphdata) = str_replace_all(names(morphdata),".1","_SE")
#write.csv(morphdata, "characterdata.csv")
```

1.05 Plate with all the tentillum diversity.
1.1 Table showing each character’s (illustrating the character per row)  the phylogenetic signal K with the p-value obtained by testing against 1000 simulated permutations, and the number of species included.
```{r phylosignals}
phylosignals = as.data.frame(matrix(ncol=3, nrow=ncol(sharedmean_logs[,-1])))
#phylosignals = as.data.frame(matrix(ncol=3, nrow=ncol(sharedmeans[,-1])))
names(phylosignals) = c("K", "P", "Ntaxa")
for(i in 2:ncol(sharedmean_logs)){
  CH_I=as.numeric(sharedmean_logs[,i])
  #CH_I=as.numeric(sharedmeans[,i])
  names(CH_I) = sharedmean_logs$Species
  #names(CH_I) = sharedmeans$Species
  SE_I = as.numeric(castSE[,i]) %>% log()
  SE_I[which(SE_I==-Inf)] = 0
  names(SE_I) = castSE$Species
  CH_I= CH_I[!is.na(CH_I)]
  SE_I= SE_I[!is.na(SE_I)]
  SE_I = SE_I[which(names(SE_I)%in%names(CH_I))]
  CH_I = CH_I[which(names(CH_I)%in%names(SE_I))]
  treeI = drop.tip(ultram,which(!(ultram$tip.label %in% names(CH_I))))
  class(treeI) = "phylo"
  #print(names(sharedmeans)[i]);print(phylosig(treeI, CH_I, se = SE_I, test=T) %>% .[c("K","P")])
  rownames(phylosignals)[i-1] <- names(sharedmean_logs)[i]
  PSIG <- phylosig(treeI, CH_I, se = SE_I, test=T)
  phylosignals[i-1,1] <- PSIG$K
  phylosignals[i-1,2] <- PSIG$P
  phylosignals[i-1,3] <- length(CH_I)
  phylosignals$K = round(phylosignals$K,3)
}
#write.csv(phylosignals, "PhylosignalsWSE_log.csv")
```


1.2 Table showing the best AICc supported model generating the data for each character and its AICc score. Model adequacy.

```{r fitContinuous}
#Model support
  Q_sharedmean_logs$Heteroneme_to_CB[which(Q_sharedmean_logs$Heteroneme_to_CB > 9)] <- NA
  AICdf = as.data.frame(matrix(ncol=6,nrow=ncol(Q_sharedmean_logs)))
  colnames(AICdf) = c("Variable", "white_noise", "starBM", "BM", "EB", "OU")
  for(c in 1:ncol(Q_sharedmean_logs)){
    startree <- rescale(ultram, "lambda", 0)
    C = Q_sharedmean_logs[,c]
    names(C) = rownames(Q_sharedmean_logs)
    C = C[!is.na(C)]
    Ctree = drop.tip(ultram, which(!(ultram$tip.label %in% names(C))))
    startree = drop.tip(startree, which(!(startree$tip.label %in% names(C))))
    Cse = castSE[,c+1] %>% log() %>% abs()
    Cse[which(Cse == Inf)] <- 0
    names(Cse) = castSE$Species
    Cse = Cse[which(names(Cse) %in% names(C))]
    model_matrix = matrix("NA", nrow = 5, ncol = 3)
    colnames(model_matrix) = c("aicc","aicc_best","dAICc")
    row.names(model_matrix) = c("white", "starBM", "BM", "EB", "OU")
    for(j in 1:dim(model_matrix)[1]){
      if(j==2){
        temp_model = fitContinuous(startree, C, model="BM", SE = Cse)$opt
      }
      else{
        temp_model = fitContinuous(Ctree, C, model=row.names(model_matrix)[j], SE = Cse)$opt
      }
      model_matrix = apply(model_matrix,2, as.numeric)
      row.names(model_matrix) = c("white", "starBM", "BM", "EB", "OU")
      model_matrix[j, "aicc"] <- temp_model$aicc
    }
    model_matrix[,"aicc_best"] <- min(model_matrix[,"aicc"])
    model_matrix[,"dAICc"] <- model_matrix[, "aicc"] - model_matrix[j, "aicc_best"]
    print(names(Q_sharedmean_logs)[c])
    string_c <- c(names(Q_sharedmean_logs)[c], model_matrix[,3])
    names(string_c) = colnames(AICdf)
    AICdf[c,] <- string_c
  }
  AICdf[,2:6] = apply(AICdf[,2:6], 2, as.numeric) %>% apply(2, round3)
  #write.csv(AICdf, "log_model_support.csv")

#Model adequacy
  worthy_models = AICdf[which(AICdf$white_noise != 0 & AICdf$starBM != 0),]
  MAD = as.data.frame(matrix(ncol = 6, nrow = nrow(worthy_models)))
  names(MAD) = c("msig", "cvar", "svar", "sasr", "shgt", "dcfd")
  rownames(MAD) = worthy_models$Variable
  for(m in 1:nrow(worthy_models)){
    C = Q_sharedmean_logs[,which(names(Q_sharedmean_logs) == worthy_models$Variable[m])]
    names(C) = rownames(Q_sharedmean_logs)
    C = C[!is.na(C)]
    Ctree = drop.tip(ultram, which(!(ultram$tip.label %in% names(C))))
    C = C[match(Ctree$tip.label, names(C))]
    class(Ctree)="phylo"
    FC <- fitContinuous(Ctree,C,model=worthy_models$Best_model[m])
    UTC <- make_unit_tree(FC)
    picstat_data <- calculate_pic_stat(UTC)
    sim <- simulate_char_unit(UTC)
    picstat_sim <- calculate_pic_stat(sim)
    compare_pic_stat(picstat_data, picstat_sim) %>% .$p.values -> MAD[m,]
  }
  phy_models = data.frame(worthy_models,MAD)
  phy_models[,7:12] = apply(phy_models[,7:12], 2,round3)
  #write.csv(phy_models, "model_adequacy.csv")
```
1.3 Figure showing major categorical character shifts, gains, and losses on a simplified phylogeny.

```{r simmaps, include=F}
par(ask=F)
tentilla = sharedcategorical$Tentilla
names(tentilla) = rownames(sharedcategorical)
prox_het = sharedcategorical$Proximal.heteronemes
names(prox_het) = rownames(sharedcategorical)
desmo = sharedcategorical$Desmonemes
names(desmo) = rownames(sharedcategorical)
rhopalo = sharedcategorical$Rhopalonemes
names(rhopalo) = rownames(sharedcategorical)
dyn_cnido = sharedcategorical$Dynamic.cnidoband
names(dyn_cnido) = rownames(sharedcategorical)
elastic = sharedcategorical$Elastic.strand
names(elastic) = rownames(sharedcategorical)
distal_desmo = sharedcategorical$Distal.cnidoband.desmonemes
names(distal_desmo) = rownames(sharedcategorical)
coiled = sharedcategorical$Coiled.tentilla
names(coiled) = rownames(sharedcategorical)
heterotype = sharedcategorical$Heteroneme.type
heterotype=as.character(heterotype)
names(heterotype) = rownames(sharedcategorical)
haplotype = sharedcategorical$Haploneme.type
haplotype=as.character(haplotype)
names(haplotype) = rownames(sharedcategorical)

Simmap_list = list()
###SIMMAP Tentilla:
make.simmap(ultram_cat, tentilla, nsim = 100) -> tentilla_sim
Simmap_list[[1]] <- tentilla_sim
plotTree(ultram_cat, lwd = 4)
tentilla_sim %>% plotSimmap(lwd = 4, add = T)
colors = c("black", "red")
names(colors) = c("Present", "Absent")
nodelabels(pie=(describe.simmap(tentilla_sim, plot=F)$ace) ,piecol=colors,cex=0.35)
add.simmap.legend(colors = colors, x=0.6*par()$usr[1],y=0.3*par()$usr[4],prompt=FALSE)
densityMap(tentilla_sim)

###SIMMAP Proximal Heteronemes:
make.simmap(ultram_cat, prox_het, nsim = 100) -> prox_het_sim
Simmap_list[[2]] <- prox_het_sim
plotTree(ultram_cat, lwd = 4)
prox_het_sim %>% plotSimmap(lwd = 4, add = T)
colors = c("black", "red")
names(colors) = c("Present", "Absent")
nodelabels(pie=(describe.simmap(prox_het_sim, plot=F)$ace) ,piecol=colors,cex=0.35)
add.simmap.legend(colors = colors, x=0.6*par()$usr[1],y=0.3*par()$usr[4],prompt=FALSE)
densityMap(prox_het_sim)

###SIMMAP Desmonemes:
make.simmap(ultram_cat, desmo, nsim = 100) -> desmo_sim
Simmap_list[[3]] <- desmo_sim
plotTree(ultram_cat, lwd = 4)
desmo_sim %>% plotSimmap(lwd = 4, add = T)
colors = c("black", "red")
names(colors) = c("Absent", "Present")
nodelabels(pie=(describe.simmap(desmo_sim, plot=F)$ace) ,piecol=colors,cex=0.35)
add.simmap.legend(colors = colors, x=0.6*par()$usr[1],y=0.3*par()$usr[4],prompt=FALSE)
densityMap(desmo_sim)

###SIMMAP Rhopalonemes:
make.simmap(ultram_cat, rhopalo, nsim = 100) -> rhopalo_sim
Simmap_list[[4]] <- rhopalo_sim
plotTree(ultram_cat, lwd = 4)
rhopalo_sim %>% plotSimmap(lwd = 4, add = T)
colors = c("black", "red")
names(colors) = c("Absent", "Present")
nodelabels(pie=(describe.simmap(rhopalo_sim, plot=F)$ace) ,piecol=colors,cex=0.35)
add.simmap.legend(colors = colors, x=0.6*par()$usr[1],y=0.3*par()$usr[4],prompt=FALSE)
densityMap(rhopalo_sim)

###SIMMAP Dynamic Cnidoband:
make.simmap(ultram_cat, dyn_cnido, nsim = 100) -> dyn_cnido_sim
Simmap_list[[5]] <- dyn_cnido_sim
plotTree(ultram_cat, lwd = 4)
dyn_cnido_sim %>% plotSimmap(lwd = 4, add = T)
colors = c("black", "red")
names(colors) = c("Absent", "Present")
nodelabels(pie=(describe.simmap(dyn_cnido_sim, plot=F)$ace) ,piecol=colors,cex=0.35)
add.simmap.legend(colors = colors, x=0.6*par()$usr[1],y=0.3*par()$usr[4],prompt=FALSE)
densityMap(dyn_cnido_sim)

###SIMMAP Elastic Strand:
make.simmap(ultram_cat, elastic, nsim = 100) -> elastic_sim
Simmap_list[[6]] <- elastic_sim
plotTree(ultram_cat, lwd = 4)
elastic_sim %>% plotSimmap(lwd = 4, add = T)
colors = c("black", "red")
names(colors) = c("Absent", "Present")
nodelabels(pie=(describe.simmap(elastic_sim, plot=F)$ace) ,piecol=colors,cex=0.35)
add.simmap.legend(colors = colors, x=0.6*par()$usr[1],y=0.3*par()$usr[4],prompt=FALSE)
densityMap(elastic_sim)

###SIMMAP Distal CB Desmonemes:
make.simmap(ultram_cat, distal_desmo, nsim = 100) -> distal_desmo_sim
Simmap_list[[7]] <- distal_desmo_sim
plotTree(ultram_cat, lwd = 4)
distal_desmo_sim %>% plotSimmap(lwd = 4, add = T)
colors = c("black", "red")
names(colors) = c("Absent", "Present")
nodelabels(pie=(describe.simmap(distal_desmo_sim, plot=F)$ace) ,piecol=colors,cex=0.35)
add.simmap.legend(colors = colors, x=0.6*par()$usr[1],y=0.3*par()$usr[4],prompt=FALSE)
densityMap(distal_desmo_sim)

###SIMMAP Tentilla Coiledness:
make.simmap(ultram_cat, coiled, nsim = 100) -> coiled_sim
Simmap_list[[8]] <- coiled_sim
plotTree(ultram_cat, lwd = 4)
coiled_sim %>% plotSimmap(lwd = 4, add = T)
colors = c("black", "red")
names(colors) = c("Absent", "Present")
nodelabels(pie=(describe.simmap(coiled_sim, plot=F)$ace) ,piecol=colors,cex=0.35)
add.simmap.legend(colors = colors, x=0.6*par()$usr[1],y=0.3*par()$usr[4],prompt=FALSE)
densityMap(coiled_sim)

###SIMMAP Heteroneme type:
heterotype = heterotype[heterotype!=""]
HTtree = drop.tip(ultram_cat, which(!(ultram_cat$tip.label %in% names(heterotype))))
make.simmap(HTtree, heterotype, nsim = 100) -> heterotype_sim
Simmap_list[[9]] <- heterotype_sim
plotTree(HTtree, lwd = 4)
heterotype_sim %>% plotSimmap(lwd = 4, add = T)
colors = c("black", "red", "green")
names(colors) = c("Eurytele", "Microbasic mastigophore", "Stenotele")
nodelabels(pie=(describe.simmap(heterotype_sim, plot=F)$ace) ,piecol=colors,cex=0.35)
add.simmap.legend(colors = colors, x=0.6*par()$usr[1],y=0.3*par()$usr[4],prompt=FALSE)

###SIMMAP Haploneme type:
haplotype = haplotype[haplotype!=""]
HTtree = drop.tip(ultram_cat, which(!(ultram_cat$tip.label %in% names(haplotype))))
make.simmap(HTtree, haplotype, nsim = 100) -> haplotype_sim
Simmap_list[[10]] <- haplotype_sim
plotTree(HTtree, lwd = 4)
haplotype_sim %>% plotSimmap(lwd = 4, add = T)
colors = c("black", "red")
names(colors) = c("Isorhizas", "Anisorhizas")
nodelabels(pie=(describe.simmap(haplotype_sim, plot=F)$ace) ,piecol=colors,cex=0.35)
add.simmap.legend(colors = colors, x=0.6*par()$usr[1],y=0.3*par()$usr[4],prompt=FALSE)
densityMap(haplotype_sim)



```



2 -- COMPARATIVE ANALYSES
2.0 Confusion matrix table showing PIC_correlations and trait correlation R2 and p-values for each pair of continuous characters.

```{r character_correlations, include=FALSE}
#PIC correlations with Rphylip
#C = sharedlogs[,c(-1,-3)] %>% .[which(!is.na(rowSums(.[,-1]))),]
C = sharedmatrix[,c(-1,-3)] %>% .[which(!is.na(rowSums(.[,-1]))),]
Cspecies = C$Species %>% as.character()
C = as.matrix(C[,-1])
rownames(C) = Cspecies
Ctree = drop.tip(ultram,which(!(ultram$tip.label %in% rownames(C))))
class(Ctree) = "phylo"
PICi = Rcontrast(tree=Ctree, X=C, path="phylip-3.695/exe", cleanup=TRUE)

#Correlation visualizations R2
phy_corr = PICi$VarA.Correlations
intra_corr = PICi$VarE.Correlations
phy_corr[upper.tri(phy_corr)] <- NA
combicorr = phy_corr
combicorr[upper.tri(combicorr)] = intra_corr[upper.tri(intra_corr)]
rownames(combicorr) = colnames(C)
colnames(combicorr) = colnames(C)
corrplot(combicorr, diag=F, tl.cex = 0.4, tl.col="black") #phylo correlations vs intraspecific correlations
PICOLS = combicorr
PICOLS[upper.tri(PICOLS)]=cor(C)[upper.tri(cor(C))]
corrplot(PICOLS, diag=F, tl.cex = 0.4, tl.col="black") #phylo correlations vs regular correlations

```



2.1 Table showing the model parameters for each significant regression.


2.3 Verbally PCA and phylogenetic PCA/PICVarA_PCA of the characters. Phylomorphospace superimposed to the tip coordinates in PC1--PC2.
```{r PCA}
par(mar=rep(3,4), mfrow=c(1,1))
raw_matrix = Q_sharedmean_logs[which(!is.na(rowSums(Q_sharedmean_logs))),c(1:2,4:20)]
compound_matrix = Q_sharedmean_logs[which(!is.na(rowSums(Q_sharedmean_logs))),c(3,21:30)]
raw_tree = drop.tip(ultram, which(!(ultram$tip.label %in% rownames(raw_matrix))))
compound_tree = drop.tip(ultram, which(!(ultram$tip.label %in% rownames(compound_matrix))))

#Regular PCA on means log
  ##Raw characters
PCA(raw_matrix) -> Pca_raw
Pca_raw %>% fviz_contrib(choice="var", axes=1, sort.val="desc")
Pca_raw %>% fviz_contrib(choice="var", axes=2, sort.val="desc")
Pca_raw %>% fviz_pca_biplot( col.var="contrib", gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"), repel = TRUE)
Pca_raw %>% fviz_pca_biplot(axes=c(3,4), col.var="contrib", gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"), repel = TRUE)
phylomorphospace(tree=raw_tree, Pca_raw$ind$coord[,1:2], label = "horizontal", xlab = "PC1", ylab = "PC2")
phylomorphospace(tree=raw_tree, Pca_raw$ind$coord[,3:4], label = "horizontal", xlab = "PC3", ylab = "PC4")
physignal(Pca_raw$ind$coord, raw_tree)
multiPhylosignal(Pca_raw$ind$coord, raw_tree)
  ##Morphometric characters
PCA(compound_matrix) -> Pca_compound
Pca_compound %>% fviz_contrib(choice="var", axes=1, sort.val="desc")
Pca_compound %>% fviz_contrib(choice="var", axes=2, sort.val="desc")
Pca_compound %>% fviz_pca_biplot( col.var="contrib", gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"), repel = TRUE)
Pca_compound %>% fviz_pca_biplot(axes=c(3,4), col.var="contrib", gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"), repel = TRUE)
phylomorphospace(tree=compound_tree, Pca_compound$ind$coord[,1:2], label = "horizontal", xlab = "PC1", ylab = "PC2")
phylomorphospace(tree=compound_tree, Pca_compound$ind$coord[,3:4], label = "horizontal", xlab = "PC3", ylab = "PC4")
physignal(Pca_compound$ind$coord, compound_tree)
multiPhylosignal(Pca_compound$ind$coord, compound_tree)

#PhyloPCA on means
PPCA_raw = phyl.pca(raw_tree, raw_matrix)
PPCA_compound = phyl.pca(compound_tree, compound_matrix)
PPCA_raw %>% biplot(main=paste(signif(summary(PPCA_raw)$importance[2,1]*100,3),"%"), ylab=paste(signif(summary(PPCA_raw)$importance[2,2]*100,3),"%"), cex = .6, expand =1)
PPCA_compound %>% biplot(main=paste(signif(summary(PPCA_compound)$importance[2,1]*100,3),"%"), ylab=paste(signif(summary(PPCA_compound)$importance[2,2]*100,3),"%"), cex = .6, expand =0.4)
phylomorphospace(raw_tree, PPCA_raw$S)
```

2.4 Table showing normalized rates of evolution for each character BAMM.

```{r BAMM}
traitlist = list()
for(i in 2:ncol(sharedmean_logs)){
  traitlist[[i]] <- sharedmean_logs[,c(1,i)]
  names(traitlist)[i] = names(sharedmean_logs)[i]
}

traitlist <- lapply(traitlist, function(x){x<-x[which(!is.nan(x[,2])),]})

for(i in 2:length(traitlist)){
  treei = drop.tip(ultram, which(!(ultram$tip.label %in% traitlist[[i]]$Species)))
  treei$tip.label = str_replace_all(treei$tip.label, " ", "_")
  write.tree(treei, file = paste("BAMM/",names(traitlist[[i]])[2], "_tree.tre", sep=""))
}

for(i in 2:length(traitlist)){
  traitlist[[i]]$Species = str_replace_all(traitlist[[i]]$Species, " ", "_")
  write.table(traitlist[[i]],file = paste("BAMM/",names(traitlist[[i]])[2], ".txt", sep=""), sep="\t", col.names = F, row.names = F, quote = F)
}

```


3 -- RELATIONSHIPS WITH DIET / FUNCTION / Hypothesis testing

```{r diet_data, include=F}
#Retrieve diet info from literature BINARY
GC = read.csv("Cmerged.csv", header = T, sep=',')[,c(2,4,5)] %>% .[which(grepl("diet",.$character) & .$state==1),]
GC$character = factor(GC$character, levels=unique(GC$character))
GC = GC[which(GC$species %in% sharedmeans$Species),]
GC = split(GC,GC$character)
nrowGC = purrr::map(GC,nrow) %>% as.numeric()
GC = GC[which(nrowGC>2)]
GC = purrr::map(GC,unique)
diet= matrix(ncol=length(GC),nrow=length(unique(sharedmeans$Species))) %>% as.data.frame()
names(diet) = names(GC)
rownames(diet) = unique(sharedmeans$Species)
for(E in GC){
  print(E$species)
  for(S in E$species){
    diet[which(rownames(diet) == S),as.character(unique(E$character))] = 1
  }
}
diet[is.na(diet)] <- 0
diet = diet[which(rowSums(diet)>0),which(colSums(diet)<nrow(diet))]
cladeB <- matrix(rep(c(0,1,0,0,0,0,0,0,0),4),nrow=9, ncol = 4) %>% t() %>% as.data.frame()
names(cladeB) = names(diet)
rownames(cladeB) = c("Erenna richardi", "Erenna laciniata", "Erenna sirena", "Stephanomia amphytridis")
diet = rbind(diet, cladeB)
#rownames(diet)[12] = 'Erenna richardi'
dprunedmatrix = sharedmeans[which(sharedmeans$Species%in%rownames(diet)),]
dprunedmatrix_logs = sharedmean_logs[which(sharedmean_logs$Species%in%rownames(diet)),]
dprunedTree = drop.tip(ultram, which(!(ultram$tip.label %in% rownames(diet))))
plot(dprunedTree)

#Retrieve diet info from literature PROPORTION RELATIVE
quantDiet = read.csv("Qmerged.csv", header = T, sep=',')[,c(2,4,6)]
PP = quantDiet[which(grepl("Relative",quantDiet$character)),]
PP$character = factor(PP$character, levels=unique(PP$character))
PP = PP[which(PP$species %in% sharedmeans$Species),]
PP = dcast(PP, species~character, value.var = "state", mean)
PP[is.na(PP)]<-0
rownames(PP) = PP$species
PP=PP[,-1]
#PP = rbind(PP, c(0,100,0,0,0,0,0,0))
#rownames(PP)[10] = "Erenna richardi"
Pprunedmatrix=sharedmeans[which(sharedmeans$Species%in%rownames(PP)),]
Pprunedmatrix_logs = sharedmean_logs[which(sharedmean_logs$Species%in%rownames(PP)),]
Pprunedtree = drop.tip(ultram, which(!(ultram$tip.label %in% rownames(PP))))
plot(Pprunedtree)

#Retrieve copepod prey length from literature
preylength = quantDiet[which(grepl("prey",quantDiet$character)),] %>% .[,c(1,3)]
names(preylength) = c("Species","Copepod prey length (mm)")
PL_pruned_matrix = sharedmeans[which(sharedmeans$Species %in% preylength$Species),] %>% data.frame(preylength[which(preylength$Species %in% sharedmeans$Species),2])
names(PL_pruned_matrix)[ncol(PL_pruned_matrix)] <- "Copepod prey length (mm)"
```

3.0 Phylogeny with the tips mapped with the literature dietary associations, and internal nodes showing SIMMAP reconstructed states.

```{r diet_regime_tree}
regimetree = dprunedTree
hypdiet = c("Mixed", "Copepod", "Crustacean", "Copepod", "Ostracod",  "Mixed", "Mixed", "Mixed", "Copepod", "Fish", "Fish", "Fish", "Fish", "Fish", "Fish")
names(hypdiet) = regimetree$tip.label
DietAnc = ace(hypdiet, regimetree, type = "discrete")$lik.anc
HypDietAnc = 1:nrow(DietAnc)
for(row in 1:nrow(DietAnc)){
  SCR = scale(DietAnc[row,])
  print(SCR)
  HypDietAnc[row] <- rownames(SCR)[which(SCR[,1] == max(SCR[,1]))] %>% print()
}
regimetree$node.label = as.factor(HypDietAnc)
plotTree(regimetree)
nodelabels(text=regimetree$node.label,frame="none",adj=c(1.6,-0.45), cex=0.6);tiplabels(text=hypdiet, frame="none", cex=0.6, adj=c(0,2))
```


3.1 Table showing quantitative and categorical characters association effect size with each prey type in the diet.

```{r prey-character-assoc}
#Phylogenetic ANOVAS with prey type presence
pANOVAs_diet = as.data.frame(matrix(ncol=ncol(dprunedmatrix_logs[,-1]), nrow=ncol(diet)))
rownames(pANOVAs_diet) = names(diet)
colnames(pANOVAs_diet) = names(dprunedmatrix_logs[,-1])
for(prey in 1:ncol(diet)){
  CH_J=diet[,prey]
  names(CH_J) = rownames(diet)
  for(char in 1:ncol(dprunedmatrix_logs[,-1])){
    CH_I = dprunedmatrix_logs[,char+1]
    names(CH_I) = dprunedmatrix_logs$Species
    CH_I = CH_I[!is.na(CH_I)]
    CH_J = CH_J[which(names(CH_J)%in%names(CH_I))]
    treeIJ = drop.tip(dprunedTree, which(!(dprunedTree$tip.label %in% names(CH_I))))
    if(length(unique(CH_I))>1 & length(unique(CH_J))>1){
    phylANOVA(treeIJ,x=CH_J,y=CH_I) %>% .$Pf -> pANOVAs_diet[prey,char]
  }
  }}
pANOVAs_diet = pANOVAs_diet[,-1]
pANOVAs_diet[pANOVAs_diet>0.05] <- NA
write.csv(pANOVAs_diet, "pANOVAS_Diet.csv")

#PGLS with proportions in Diet
pGLSp_diet = as.data.frame(matrix(nrow=ncol(Pprunedmatrix_logs[,-1]), ncol=ncol(PP)))
pGLS_sign = pGLSp_diet
colnames(pGLSp_diet) = names(PP)
row.names(pGLSp_diet) = names(Pprunedmatrix_logs[,-1])
pGLS_sign = pGLSp_diet
for(i in 1:ncol(Pprunedmatrix_logs[,-1])){
  CH_I=as.numeric(Pprunedmatrix_logs[,i+1])
  names(CH_I) = Pprunedmatrix_logs$Species
  CH_I = CH_I[!is.na(CH_I)]
  for(j in 1:ncol(PP)){
    CH_J=as.numeric(PP[,j])
    names(CH_J) = rownames(PP)
    CH_J = CH_J[!is.na(CH_J)]
    CH_I = CH_I[which(names(CH_I) %in% names(CH_J))]
    CH_J = CH_J[which(names(CH_J) %in% names(CH_I))]
    pgls_tree = drop.tip(Pprunedtree, which(!(Pprunedtree$tip.label %in% names(CH_I))))
    pg_data = as.data.frame(cbind(CH_I,CH_J)) %>% .[which(!is.na(rowSums(.))),]
    TTABLE <- gls(CH_I ~ CH_J, correlation =  corBrownian(phy = pgls_tree), data = pg_data, method = "ML") %>% summary() %>% .$tTable %>% as.data.frame()
    TTABLE %>% .$p %>% .[2] -> pGLSp_diet[i,j]
    if(pGLSp_diet[i,j]<0.05){
      print(paste(rownames(pGLSp_diet)[i],colnames(pGLSp_diet)[j],pGLSp_diet[(i),(j)],sep=" "))
      ValueIJ = TTABLE %>% .$Value %>% .[2]
      if(ValueIJ>0){pGLS_sign[i,j] = "+"}
      else pGLS_sign[i,j] = "-"
    }}}
write.csv(pGLSp_diet, "PGLS_Pval_DietPP.csv")
pGLS_sign <- pGLS_sign[which(rowSums(is.na(pGLS_sign))!=ncol(pGLS_sign)),which(colSums(is.na(pGLS_sign))!=nrow(pGLS_sign))]
write.csv(pGLS_sign, "PGLS_SIGN_DietPP.csv")

```

3.2 Table showing the dAICc of OU model fitting versus white_noise and BM using reconstructed diets as regimes in a 16spp tree. Evaluate model adequacy of OU fits.

```{r OUwie}
OUwie_matrix = as.data.frame(matrix(ncol=4, nrow=nrow(dprunedmatrix_logs)))
names(OUwie_matrix) = c("Character", "Ntips", "dAICc_BM", "dAICc_OU")
library(magrittr)
for(c in 2:ncol(dprunedmatrix_logs)){
  Cdata = data.frame(dprunedmatrix$Species,hypdiet,dprunedmatrix_logs[,c])
  names(Cdata) = c("species", "regime", "trait")
  Cdata$trait[which(Cdata$trait == "NaN")] <- NA
  Cdata = Cdata[!is.na(Cdata$trait),]
  Cdata$trait = as.numeric(Cdata$trait)
  Cdata$species = as.character(Cdata$species)
  Cdata$regime = as.character(Cdata$regime)
  Ctree = drop.tip(regimetree,which(!(regimetree$tip.label %in% Cdata$species)))
  BM <- OUwie(Ctree, Cdata, model="BM1")
  OU <- OUwie(Ctree, Cdata, model="OU1")
  OUwie_matrix[c-1,1] = names(dprunedmatrix_logs)[c]
  OUwie_matrix[c-1,2] = nrow(Cdata)
  OUwie_matrix[c-1,3] = BM$AICc - min(c(BM$AICc, OU$AICc))
  OUwie_matrix[c-1,4] = OU$AICc - min(c(BM$AICc, OU$AICc))
}
OUwie_matrix[,3:4] <- apply(OUwie_matrix[,3:4], 2, round3)
#write.csv(OUwie_matrix, "OU_diet_test.csv")
```

3.3 Interpret qualitatively the kinematic implications (high speed video) of the different regions of the morphospace.

Story: low dimensionality, cost-driven, dynamic specialization

## 4. Discussion

## 5. Conclusions

## Acknowledgements

This work was funded by the Society of Systematic Biologists Graduate Student Award, the NSF Waterman Award, and the Yale Institute of Biospheric Studies Doctoral Pilot Grant. ADS was supported by a Fulbright Spain scholarship. We thank Philip R. Pugh for his assistance in the identification of specimens. We also wish to thank the crew of the R/V Western Flyer.

## References
